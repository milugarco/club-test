/* tslint:disable */
/* eslint-disable */
/**
 * Invicta API DEV
 * Utilize essa documentação para realizar integração com o nosso sistema
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountInitialSubscribe
 */
export interface AccountInitialSubscribe {
    /**
     * The corporate name of the account
     * @type {string}
     * @memberof AccountInitialSubscribe
     */
    'name': string;
    /**
     * The document number of the account
     * @type {string}
     * @memberof AccountInitialSubscribe
     */
    'document': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInitialSubscribe
     */
    'dateOfBirth': string;
}
/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'corporateName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'fantasyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'photo'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'segment'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'document'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'documentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'neighborhood'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'complement'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'status'?: AccountResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'countryCodePhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'areaCodePhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'deletedAt'?: string;
}

export const AccountResponseStatusEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;

export type AccountResponseStatusEnum = typeof AccountResponseStatusEnum[keyof typeof AccountResponseStatusEnum];

/**
 * 
 * @export
 * @interface AccountUserResponse
 */
export interface AccountUserResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountUserResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountUserResponse
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountUserResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountUserResponse
     */
    'status'?: AccountUserResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountUserResponse
     */
    'type'?: AccountUserResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountUserResponse
     */
    'position'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountUserResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountUserResponse
     */
    'updatedAt'?: string;
}

export const AccountUserResponseStatusEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;

export type AccountUserResponseStatusEnum = typeof AccountUserResponseStatusEnum[keyof typeof AccountUserResponseStatusEnum];
export const AccountUserResponseTypeEnum = {
    Team: 'TEAM',
    Student: 'STUDENT'
} as const;

export type AccountUserResponseTypeEnum = typeof AccountUserResponseTypeEnum[keyof typeof AccountUserResponseTypeEnum];

/**
 * 
 * @export
 * @interface AccountsResponse
 */
export interface AccountsResponse {
    /**
     * 
     * @type {Array<ResponseAccountDto>}
     * @memberof AccountsResponse
     */
    'data': Array<ResponseAccountDto>;
    /**
     * 
     * @type {PageInfo}
     * @memberof AccountsResponse
     */
    'pageInfo': PageInfo | null;
}
/**
 * 
 * @export
 * @interface AccountsUserResponse
 */
export interface AccountsUserResponse {
    /**
     * 
     * @type {Array<ResponseAccountUserDto>}
     * @memberof AccountsUserResponse
     */
    'data': Array<ResponseAccountUserDto>;
    /**
     * 
     * @type {PageInfo}
     * @memberof AccountsUserResponse
     */
    'pageInfo': PageInfo | null;
}
/**
 * 
 * @export
 * @interface AddressResponse
 */
export interface AddressResponse {
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'country'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddressResponse
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface AddressesResponse
 */
export interface AddressesResponse {
    /**
     * 
     * @type {Array<CreateAddressDto>}
     * @memberof AddressesResponse
     */
    'data': Array<CreateAddressDto>;
    /**
     * 
     * @type {PageInfo}
     * @memberof AddressesResponse
     */
    'pageInfo': PageInfo | null;
}
/**
 * 
 * @export
 * @interface ChangePasswordOtpDto
 */
export interface ChangePasswordOtpDto {
    /**
     * Senha OTP
     * @type {string}
     * @memberof ChangePasswordOtpDto
     */
    'number': string;
    /**
     * HASH
     * @type {string}
     * @memberof ChangePasswordOtpDto
     */
    'hash': string;
    /**
     * Nova senha para o usuário
     * @type {string}
     * @memberof ChangePasswordOtpDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CreateAccountDto
 */
export interface CreateAccountDto {
    /**
     * The name of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'name': string;
    /**
     * The corporate name of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'corporateName': string;
    /**
     * The fantasy name of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'fantasyName': string;
    /**
     * The segment of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'segment': string;
    /**
     * The document number of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'document': string;
    /**
     * The type of document (CNPJ)
     * @type {string}
     * @memberof CreateAccountDto
     */
    'documentType': string;
    /**
     * The domain of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'domain'?: string;
    /**
     * The email of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'email': string;
    /**
     * The street address of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'street': string;
    /**
     * The state of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'state': string;
    /**
     * The city of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'city': string;
    /**
     * The neighborhood of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'neighborhood': string;
    /**
     * The country of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'country': string;
    /**
     * The ZIP code of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'zipCode': string;
    /**
     * The complement of the address
     * @type {string}
     * @memberof CreateAccountDto
     */
    'complement'?: string;
    /**
     * The status of the account
     * @type {string}
     * @memberof CreateAccountDto
     */
    'status': CreateAccountDtoStatusEnum;
    /**
     * The country code of the phone number
     * @type {string}
     * @memberof CreateAccountDto
     */
    'countryCodePhone': string;
    /**
     * The area code of the phone number
     * @type {string}
     * @memberof CreateAccountDto
     */
    'areaCodePhone': string;
    /**
     * The phone number
     * @type {string}
     * @memberof CreateAccountDto
     */
    'phoneNumber': string;
}

export const CreateAccountDtoStatusEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;

export type CreateAccountDtoStatusEnum = typeof CreateAccountDtoStatusEnum[keyof typeof CreateAccountDtoStatusEnum];

/**
 * 
 * @export
 * @interface CreateAccountUserDto
 */
export interface CreateAccountUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAccountUserDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountUserDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountUserDto
     */
    'status': CreateAccountUserDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountUserDto
     */
    'type': CreateAccountUserDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountUserDto
     */
    'position': string;
}

export const CreateAccountUserDtoStatusEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;

export type CreateAccountUserDtoStatusEnum = typeof CreateAccountUserDtoStatusEnum[keyof typeof CreateAccountUserDtoStatusEnum];
export const CreateAccountUserDtoTypeEnum = {
    Team: 'TEAM',
    Student: 'STUDENT'
} as const;

export type CreateAccountUserDtoTypeEnum = typeof CreateAccountUserDtoTypeEnum[keyof typeof CreateAccountUserDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateAddressDto
 */
export interface CreateAddressDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'country': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAddressDto
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface CreateDocumentClubDTO
 */
export interface CreateDocumentClubDTO {
    /**
     * Número do documento
     * @type {string}
     * @memberof CreateDocumentClubDTO
     */
    'number': string;
    /**
     * Tipo do documento
     * @type {string}
     * @memberof CreateDocumentClubDTO
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface CreateDocumentDto
 */
export interface CreateDocumentDto {
    /**
     * Número do documento
     * @type {string}
     * @memberof CreateDocumentDto
     */
    'number': string;
    /**
     * Tipo do documento
     * @type {string}
     * @memberof CreateDocumentDto
     */
    'type': string;
    /**
     * Path do documento no computador
     * @type {string}
     * @memberof CreateDocumentDto
     */
    'filePath': string;
    /**
     * 
     * @type {CreateUserDocumentDto}
     * @memberof CreateDocumentDto
     */
    'userDocument': CreateUserDocumentDto;
}
/**
 * 
 * @export
 * @interface CreateEventDto
 */
export interface CreateEventDto {
    /**
     * Nome do evento
     * @type {string}
     * @memberof CreateEventDto
     */
    'name': string;
    /**
     * Subtítulo do evento
     * @type {string}
     * @memberof CreateEventDto
     */
    'subtitle': string;
    /**
     * Tipo do evento
     * @type {string}
     * @memberof CreateEventDto
     */
    'type': string;
    /**
     * Cor primária do evento
     * @type {string}
     * @memberof CreateEventDto
     */
    'colorOne': string;
    /**
     * Cor secundária do evento
     * @type {string}
     * @memberof CreateEventDto
     */
    'colorTwo': string;
    /**
     * Descrição do evento
     * @type {string}
     * @memberof CreateEventDto
     */
    'description': string;
    /**
     * Informação do evento
     * @type {string}
     * @memberof CreateEventDto
     */
    'information': string;
    /**
     * Informações do evento enviados por email
     * @type {string}
     * @memberof CreateEventDto
     */
    'informationEmail': string;
    /**
     * Vídeo do evento
     * @type {string}
     * @memberof CreateEventDto
     */
    'video': string;
    /**
     * Redirecionamento depois que preencher os participantes
     * @type {string}
     * @memberof CreateEventDto
     */
    'redirect': string;
    /**
     * Link para acionar conversa/grupo no whatsapp na página de obrigado
     * @type {string}
     * @memberof CreateEventDto
     */
    'whatsappLink': string;
    /**
     * Link para acionar conversa/grupo no telegram na página de obrigado
     * @type {string}
     * @memberof CreateEventDto
     */
    'telegramLink': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventDto
     */
    'status': CreateEventDtoStatusEnum;
    /**
     * Data e hora de inicio do evento 
     * @type {string}
     * @memberof CreateEventDto
     */
    'startAt': string;
    /**
     * Data e hora de fim do evento
     * @type {string}
     * @memberof CreateEventDto
     */
    'endAt': string;
    /**
     * Data e hora de inicio do evento 
     * @type {string}
     * @memberof CreateEventDto
     */
    'startPublishAt': string;
    /**
     * Data e hora de fim do evento
     * @type {string}
     * @memberof CreateEventDto
     */
    'endPublishAt': string;
}

export const CreateEventDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type CreateEventDtoStatusEnum = typeof CreateEventDtoStatusEnum[keyof typeof CreateEventDtoStatusEnum];

/**
 * 
 * @export
 * @interface CreateEventParticipantClubDto
 */
export interface CreateEventParticipantClubDto {
    /**
     * ID da conta associado ao evento
     * @type {string}
     * @memberof CreateEventParticipantClubDto
     */
    'accountId': string;
    /**
     * ID do usuário associado ao participante
     * @type {string}
     * @memberof CreateEventParticipantClubDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipantClubDto
     */
    'status': CreateEventParticipantClubDtoStatusEnum;
}

export const CreateEventParticipantClubDtoStatusEnum = {
    AwaitingPayment: 'AWAITING_PAYMENT',
    CheckInEarly: 'CHECK_IN_EARLY',
    CheckIn: 'CHECK_IN',
    CheckOut: 'CHECK_OUT',
    Canceled: 'CANCELED',
    Enable: 'ENABLE'
} as const;

export type CreateEventParticipantClubDtoStatusEnum = typeof CreateEventParticipantClubDtoStatusEnum[keyof typeof CreateEventParticipantClubDtoStatusEnum];

/**
 * 
 * @export
 * @interface CreateEventParticipantDto
 */
export interface CreateEventParticipantDto {
    /**
     * ID do usuário associado ao participante
     * @type {string}
     * @memberof CreateEventParticipantDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipantDto
     */
    'status': CreateEventParticipantDtoStatusEnum;
}

export const CreateEventParticipantDtoStatusEnum = {
    AwaitingPayment: 'AWAITING_PAYMENT',
    CheckInEarly: 'CHECK_IN_EARLY',
    CheckIn: 'CHECK_IN',
    CheckOut: 'CHECK_OUT',
    Canceled: 'CANCELED',
    Enable: 'ENABLE'
} as const;

export type CreateEventParticipantDtoStatusEnum = typeof CreateEventParticipantDtoStatusEnum[keyof typeof CreateEventParticipantDtoStatusEnum];

/**
 * 
 * @export
 * @interface CreateEventParticipantStatusDto
 */
export interface CreateEventParticipantStatusDto {
    /**
     * Event ticket guest status
     * @type {string}
     * @memberof CreateEventParticipantStatusDto
     */
    'status': CreateEventParticipantStatusDtoStatusEnum;
    /**
     * ID do evento associado ao ticket (UUID)
     * @type {string}
     * @memberof CreateEventParticipantStatusDto
     */
    'eventParticipantId': string;
}

export const CreateEventParticipantStatusDtoStatusEnum = {
    Checkin: 'CHECKIN',
    Checkout: 'CHECKOUT',
    Pending: 'PENDING'
} as const;

export type CreateEventParticipantStatusDtoStatusEnum = typeof CreateEventParticipantStatusDtoStatusEnum[keyof typeof CreateEventParticipantStatusDtoStatusEnum];

/**
 * 
 * @export
 * @interface CreateEventTicketDto
 */
export interface CreateEventTicketDto {
    /**
     * ID do evento associado ao ticket (UUID)
     * @type {string}
     * @memberof CreateEventTicketDto
     */
    'eventId': string;
    /**
     * Nome do participante
     * @type {string}
     * @memberof CreateEventTicketDto
     */
    'name': string;
    /**
     * Descrição do ingresso
     * @type {string}
     * @memberof CreateEventTicketDto
     */
    'description': string;
    /**
     * Preço do ingresso
     * @type {number}
     * @memberof CreateEventTicketDto
     */
    'price': number;
    /**
     * Preço antes do desconto
     * @type {number}
     * @memberof CreateEventTicketDto
     */
    'priceBefore': number;
    /**
     * 
     * @type {string}
     * @memberof CreateEventTicketDto
     */
    'status': CreateEventTicketDtoStatusEnum;
    /**
     * Cor do ingresso
     * @type {string}
     * @memberof CreateEventTicketDto
     */
    'color'?: string;
    /**
     * Número de convidados
     * @type {number}
     * @memberof CreateEventTicketDto
     */
    'guest'?: number;
}

export const CreateEventTicketDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type CreateEventTicketDtoStatusEnum = typeof CreateEventTicketDtoStatusEnum[keyof typeof CreateEventTicketDtoStatusEnum];

/**
 * 
 * @export
 * @interface CreateEventTicketGuestDto
 */
export interface CreateEventTicketGuestDto {
    /**
     * Quantidade de convites a serem gerados
     * @type {number}
     * @memberof CreateEventTicketGuestDto
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface CreateInitialSubscribeDto
 */
export interface CreateInitialSubscribeDto {
    /**
     * 
     * @type {UserInitialSubscribe}
     * @memberof CreateInitialSubscribeDto
     */
    'user': UserInitialSubscribe;
    /**
     * 
     * @type {AccountInitialSubscribe}
     * @memberof CreateInitialSubscribeDto
     */
    'account': AccountInitialSubscribe;
}
/**
 * 
 * @export
 * @interface CreateOtpDto
 */
export interface CreateOtpDto {
    /**
     * Tipo OTP
     * @type {string}
     * @memberof CreateOtpDto
     */
    'type': CreateOtpDtoTypeEnum;
    /**
     * Email
     * @type {string}
     * @memberof CreateOtpDto
     */
    'userEmail': string;
}

export const CreateOtpDtoTypeEnum = {
    Otp: 'OTP',
    Recovery: 'RECOVERY'
} as const;

export type CreateOtpDtoTypeEnum = typeof CreateOtpDtoTypeEnum[keyof typeof CreateOtpDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateUserDocumentDto
 */
export interface CreateUserDocumentDto {
    /**
     * ID do usuário (UUID)
     * @type {string}
     * @memberof CreateUserDocumentDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'status': CreateUserDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'countryCodePhone': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'areaCodePhone': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'dateOfBirth': string;
}

export const CreateUserDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    WaitingConfirmation: 'WAITING_CONFIRMATION'
} as const;

export type CreateUserDtoStatusEnum = typeof CreateUserDtoStatusEnum[keyof typeof CreateUserDtoStatusEnum];

/**
 * 
 * @export
 * @interface DeleteAddressResponse
 */
export interface DeleteAddressResponse {
    /**
     * 
     * @type {string}
     * @memberof DeleteAddressResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteUserResponse
 */
export interface DeleteUserResponse {
    /**
     * 
     * @type {string}
     * @memberof DeleteUserResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DocumentResponse
 */
export interface DocumentResponse {
    /**
     * ID do documento (UUID)
     * @type {string}
     * @memberof DocumentResponse
     */
    'id'?: string;
    /**
     * Número do documento
     * @type {string}
     * @memberof DocumentResponse
     */
    'number'?: string;
    /**
     * Tipo do documento
     * @type {string}
     * @memberof DocumentResponse
     */
    'type'?: string;
    /**
     * Path do documento no computador
     * @type {string}
     * @memberof DocumentResponse
     */
    'filePath'?: string;
    /**
     * Path da foto do verso de document
     * @type {string}
     * @memberof DocumentResponse
     */
    'filePathBack'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'status'?: DocumentResponseStatusEnum;
    /**
     * Data e hora da criação do documento
     * @type {string}
     * @memberof DocumentResponse
     */
    'createdAt'?: string;
    /**
     * Data e hora da última atualização no documento
     * @type {string}
     * @memberof DocumentResponse
     */
    'updatedAt'?: string;
    /**
     * Data e hora da exclusão do documento
     * @type {string}
     * @memberof DocumentResponse
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {Array<UserDocumentResponseDto>}
     * @memberof DocumentResponse
     */
    'userDocument'?: Array<UserDocumentResponseDto>;
}

export const DocumentResponseStatusEnum = {
    Sent: 'SENT',
    AwaitingVerification: 'AWAITING_VERIFICATION',
    Verified: 'VERIFIED'
} as const;

export type DocumentResponseStatusEnum = typeof DocumentResponseStatusEnum[keyof typeof DocumentResponseStatusEnum];

/**
 * 
 * @export
 * @interface DocumentsResponse
 */
export interface DocumentsResponse {
    /**
     * 
     * @type {Array<ResponseDocumentDto>}
     * @memberof DocumentsResponse
     */
    'data': Array<ResponseDocumentDto>;
    /**
     * 
     * @type {PageInfo}
     * @memberof DocumentsResponse
     */
    'pageInfo': PageInfo | null;
}
/**
 * 
 * @export
 * @interface EventClubResponse
 */
export interface EventClubResponse {
    /**
     * ID do evento (UUID)
     * @type {string}
     * @memberof EventClubResponse
     */
    'id'?: string;
    /**
     * ID sequencial do evento
     * @type {number}
     * @memberof EventClubResponse
     */
    'sequential'?: number;
    /**
     * ID da conta associada ao evento (UUID)
     * @type {string}
     * @memberof EventClubResponse
     */
    'accountId'?: string;
    /**
     * Nome do evento
     * @type {string}
     * @memberof EventClubResponse
     */
    'name'?: string;
    /**
     * Subtítulo do evento
     * @type {string}
     * @memberof EventClubResponse
     */
    'subtitle'?: string;
    /**
     * URL da foto do evento
     * @type {string}
     * @memberof EventClubResponse
     */
    'photo'?: string;
    /**
     * Cor primária do evento
     * @type {string}
     * @memberof EventClubResponse
     */
    'colorOne'?: string;
    /**
     * Cor secundária do evento
     * @type {string}
     * @memberof EventClubResponse
     */
    'colorTwo'?: string;
    /**
     * Descrição do evento
     * @type {string}
     * @memberof EventClubResponse
     */
    'description'?: string;
    /**
     * Informação do evento
     * @type {string}
     * @memberof EventClubResponse
     */
    'information'?: string;
    /**
     * Informações do evento enviados por email
     * @type {string}
     * @memberof EventClubResponse
     */
    'informationEmail'?: string;
    /**
     * Vídeo do evento
     * @type {string}
     * @memberof EventClubResponse
     */
    'video'?: string;
    /**
     * Link para acionar conversa/grupo no whatsApp na página de obrigado
     * @type {string}
     * @memberof EventClubResponse
     */
    'whatsappLink'?: string;
    /**
     * Link para acionar conversa/grupo no telegram na página de obrigado
     * @type {string}
     * @memberof EventClubResponse
     */
    'telegramLink'?: string;
    /**
     * Data e hora de inicio do evento 
     * @type {string}
     * @memberof EventClubResponse
     */
    'startAt'?: string;
    /**
     * Data e hora de fim do evento
     * @type {string}
     * @memberof EventClubResponse
     */
    'endAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventClubResponse
     */
    'status'?: EventClubResponseStatusEnum;
    /**
     * 
     * @type {Array<ResponseEventConfigClubDto>}
     * @memberof EventClubResponse
     */
    'eventConfig'?: Array<ResponseEventConfigClubDto>;
}

export const EventClubResponseStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type EventClubResponseStatusEnum = typeof EventClubResponseStatusEnum[keyof typeof EventClubResponseStatusEnum];

/**
 * 
 * @export
 * @interface EventConfigResponse
 */
export interface EventConfigResponse {
    /**
     * 
     * @type {ResponseEventConfigDto}
     * @memberof EventConfigResponse
     */
    'data': ResponseEventConfigDto;
}
/**
 * 
 * @export
 * @interface EventParticipantClubGuestResponse
 */
export interface EventParticipantClubGuestResponse {
    /**
     * ID do participante (UUID)
     * @type {string}
     * @memberof EventParticipantClubGuestResponse
     */
    'id'?: string;
    /**
     * ID sequencial do participante
     * @type {number}
     * @memberof EventParticipantClubGuestResponse
     */
    'sequential'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantClubGuestResponse
     */
    'status'?: EventParticipantClubGuestResponseStatusEnum;
    /**
     * QRcode do participante
     * @type {string}
     * @memberof EventParticipantClubGuestResponse
     */
    'qrCode'?: string;
    /**
     * photo path in aws
     * @type {string}
     * @memberof EventParticipantClubGuestResponse
     */
    'path'?: string;
    /**
     * 
     * @type {UserGuestClubResponse}
     * @memberof EventParticipantClubGuestResponse
     */
    'user'?: UserGuestClubResponse;
}

export const EventParticipantClubGuestResponseStatusEnum = {
    AwaitingPayment: 'AWAITING_PAYMENT',
    CheckInEarly: 'CHECK_IN_EARLY',
    CheckIn: 'CHECK_IN',
    CheckOut: 'CHECK_OUT',
    Canceled: 'CANCELED',
    Enable: 'ENABLE'
} as const;

export type EventParticipantClubGuestResponseStatusEnum = typeof EventParticipantClubGuestResponseStatusEnum[keyof typeof EventParticipantClubGuestResponseStatusEnum];

/**
 * 
 * @export
 * @interface EventParticipantResponse
 */
export interface EventParticipantResponse {
    /**
     * ID do participante (UUID)
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'id': string;
    /**
     * ID sequencial do participante
     * @type {number}
     * @memberof EventParticipantResponse
     */
    'sequential': number;
    /**
     * ID da conta associada ao participante (UUID)
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'accountId': string;
    /**
     * ID do evento associado ao participante (UUID)
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'eventId': string;
    /**
     * ID do ingresso associada ao participante (UUID)
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'eventTicketId': string;
    /**
     * ID do ingresso associada ao participante (UUID)
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'eventTicketGuestId': string;
    /**
     * ID do usuário associado ao participante
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'status': EventParticipantResponseStatusEnum;
    /**
     * QRcode do participante
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'qrCode': string;
    /**
     * photo path in aws
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'path': string;
    /**
     * Data de criação do evento
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'createdAt': string;
    /**
     * Data de atualização do evento
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'updatedAt': string;
    /**
     * Data de exclusão do evento (se aplicável)
     * @type {string}
     * @memberof EventParticipantResponse
     */
    'deletedAt': string;
}

export const EventParticipantResponseStatusEnum = {
    AwaitingPayment: 'AWAITING_PAYMENT',
    CheckInEarly: 'CHECK_IN_EARLY',
    CheckIn: 'CHECK_IN',
    CheckOut: 'CHECK_OUT',
    Canceled: 'CANCELED',
    Enable: 'ENABLE'
} as const;

export type EventParticipantResponseStatusEnum = typeof EventParticipantResponseStatusEnum[keyof typeof EventParticipantResponseStatusEnum];

/**
 * 
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * ID do evento (UUID)
     * @type {string}
     * @memberof EventResponse
     */
    'id'?: string;
    /**
     * ID sequencial do evento
     * @type {number}
     * @memberof EventResponse
     */
    'sequential'?: number;
    /**
     * ID da conta associada ao evento (UUID)
     * @type {string}
     * @memberof EventResponse
     */
    'accountId'?: string;
    /**
     * ID do usuário associado ao evento (UUID)
     * @type {string}
     * @memberof EventResponse
     */
    'userId'?: string;
    /**
     * Nome do evento
     * @type {string}
     * @memberof EventResponse
     */
    'name'?: string;
    /**
     * Subtítulo do evento
     * @type {string}
     * @memberof EventResponse
     */
    'subtitle'?: string;
    /**
     * URI do evento
     * @type {string}
     * @memberof EventResponse
     */
    'uri'?: string;
    /**
     * Tipo do evento
     * @type {string}
     * @memberof EventResponse
     */
    'type'?: string;
    /**
     * URL da foto do evento
     * @type {string}
     * @memberof EventResponse
     */
    'photo'?: string;
    /**
     * Cor primária do evento
     * @type {string}
     * @memberof EventResponse
     */
    'colorOne'?: string;
    /**
     * Cor secundária do evento
     * @type {string}
     * @memberof EventResponse
     */
    'colorTwo'?: string;
    /**
     * Descrição do evento
     * @type {string}
     * @memberof EventResponse
     */
    'description'?: string;
    /**
     * Informação do evento
     * @type {string}
     * @memberof EventResponse
     */
    'information'?: string;
    /**
     * Informações do evento enviados por email
     * @type {string}
     * @memberof EventResponse
     */
    'informationEmail'?: string;
    /**
     * Vídeo do evento
     * @type {string}
     * @memberof EventResponse
     */
    'video'?: string;
    /**
     * Redirecionamento depois que preencher os participantes
     * @type {string}
     * @memberof EventResponse
     */
    'redirect'?: string;
    /**
     * Link para acionar conversa/grupo no whatsApp na página de obrigado
     * @type {string}
     * @memberof EventResponse
     */
    'whatsappLink'?: string;
    /**
     * Link para acionar conversa/grupo no telegram na página de obrigado
     * @type {string}
     * @memberof EventResponse
     */
    'telegramLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'status'?: EventResponseStatusEnum;
    /**
     * Data e hora de inicio do evento 
     * @type {string}
     * @memberof EventResponse
     */
    'startAt'?: string;
    /**
     * Data e hora de fim do evento
     * @type {string}
     * @memberof EventResponse
     */
    'endAt'?: string;
    /**
     * Data e hora de inicio do evento 
     * @type {string}
     * @memberof EventResponse
     */
    'startPublishAt'?: string;
    /**
     * Data e hora de fim do evento
     * @type {string}
     * @memberof EventResponse
     */
    'endPublishAt'?: string;
    /**
     * Data de criação do evento
     * @type {string}
     * @memberof EventResponse
     */
    'createdAt'?: string;
    /**
     * Data de atualização do evento
     * @type {string}
     * @memberof EventResponse
     */
    'updatedAt'?: string;
    /**
     * Data de exclusão do evento (se aplicável)
     * @type {string}
     * @memberof EventResponse
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {Array<ResponseEventConfigDto>}
     * @memberof EventResponse
     */
    'eventConfig'?: Array<ResponseEventConfigDto>;
}

export const EventResponseStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type EventResponseStatusEnum = typeof EventResponseStatusEnum[keyof typeof EventResponseStatusEnum];

/**
 * 
 * @export
 * @interface EventTicketClubResponse
 */
export interface EventTicketClubResponse {
    /**
     * ID do ticket evento (UUID)
     * @type {string}
     * @memberof EventTicketClubResponse
     */
    'id'?: string;
    /**
     * ID sequencial do ingresso
     * @type {number}
     * @memberof EventTicketClubResponse
     */
    'sequential'?: number;
    /**
     * Nome do ticket
     * @type {string}
     * @memberof EventTicketClubResponse
     */
    'name'?: string;
    /**
     * Status do ingresso
     * @type {string}
     * @memberof EventTicketClubResponse
     */
    'status'?: EventTicketClubResponseStatusEnum;
    /**
     * Cor do ingresso
     * @type {string}
     * @memberof EventTicketClubResponse
     */
    'color'?: string;
}

export const EventTicketClubResponseStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type EventTicketClubResponseStatusEnum = typeof EventTicketClubResponseStatusEnum[keyof typeof EventTicketClubResponseStatusEnum];

/**
 * 
 * @export
 * @interface EventTicketGuestClubResponse
 */
export interface EventTicketGuestClubResponse {
    /**
     * testeID da URL ticket evento (UUID)
     * @type {string}
     * @memberof EventTicketGuestClubResponse
     */
    'id'?: string;
    /**
     * ID da URL ticket evento (UUID)
     * @type {string}
     * @memberof EventTicketGuestClubResponse
     */
    'eventId'?: string;
    /**
     * ID da URL ticket evento (UUID)
     * @type {string}
     * @memberof EventTicketGuestClubResponse
     */
    'eventTicketId'?: string;
    /**
     * Data de criação
     * @type {string}
     * @memberof EventTicketGuestClubResponse
     */
    'createdAt'?: string;
    /**
     * Data de atualização
     * @type {string}
     * @memberof EventTicketGuestClubResponse
     */
    'updatedAt'?: string;
    /**
     * Data de exclusão (se aplicável)
     * @type {string}
     * @memberof EventTicketGuestClubResponse
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {EventTicketClubResponse}
     * @memberof EventTicketGuestClubResponse
     */
    'eventTicket'?: EventTicketClubResponse;
    /**
     * 
     * @type {EventClubResponse}
     * @memberof EventTicketGuestClubResponse
     */
    'event'?: EventClubResponse;
    /**
     * 
     * @type {Array<EventParticipantClubGuestResponse>}
     * @memberof EventTicketGuestClubResponse
     */
    'eventParticipant'?: Array<EventParticipantClubGuestResponse>;
}
/**
 * 
 * @export
 * @interface EventTicketGuestDto
 */
export interface EventTicketGuestDto {
    /**
     * 
     * @type {string}
     * @memberof EventTicketGuestDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface EventTicketResponse
 */
export interface EventTicketResponse {
    /**
     * ID do ticket evento (UUID)
     * @type {string}
     * @memberof EventTicketResponse
     */
    'id'?: string;
    /**
     * ID sequencial do ingresso
     * @type {number}
     * @memberof EventTicketResponse
     */
    'sequential'?: number;
    /**
     * ID da conta associada ao ticket (UUID)
     * @type {string}
     * @memberof EventTicketResponse
     */
    'accountId'?: string;
    /**
     * ID do evento associado ao ticket (UUID)
     * @type {string}
     * @memberof EventTicketResponse
     */
    'eventId'?: string;
    /**
     * Nome do ticket
     * @type {string}
     * @memberof EventTicketResponse
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventTicketResponse
     */
    'price'?: object;
    /**
     * 
     * @type {object}
     * @memberof EventTicketResponse
     */
    'priceBefore'?: object;
    /**
     * Status do ingresso
     * @type {string}
     * @memberof EventTicketResponse
     */
    'status'?: EventTicketResponseStatusEnum;
    /**
     * Cor do ingresso
     * @type {string}
     * @memberof EventTicketResponse
     */
    'color'?: string;
    /**
     * Número de convidados
     * @type {number}
     * @memberof EventTicketResponse
     */
    'guest'?: number;
    /**
     * Data de criação
     * @type {string}
     * @memberof EventTicketResponse
     */
    'createdAt'?: string;
    /**
     * Data de atualização
     * @type {string}
     * @memberof EventTicketResponse
     */
    'updatedAt'?: string;
    /**
     * Data de exclusão (se aplicável)
     * @type {string}
     * @memberof EventTicketResponse
     */
    'deletedAt'?: string;
}

export const EventTicketResponseStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type EventTicketResponseStatusEnum = typeof EventTicketResponseStatusEnum[keyof typeof EventTicketResponseStatusEnum];

/**
 * 
 * @export
 * @interface EventsParticipantsClubResponse
 */
export interface EventsParticipantsClubResponse {
    /**
     * 
     * @type {Array<ResponseEventParticipantClubDto>}
     * @memberof EventsParticipantsClubResponse
     */
    'data': Array<ResponseEventParticipantClubDto>;
    /**
     * 
     * @type {PageInfo}
     * @memberof EventsParticipantsClubResponse
     */
    'pageInfo': PageInfo | null;
}
/**
 * 
 * @export
 * @interface EventsResponse
 */
export interface EventsResponse {
    /**
     * 
     * @type {Array<ResponseEventDto>}
     * @memberof EventsResponse
     */
    'data': Array<ResponseEventDto>;
    /**
     * 
     * @type {PageInfo}
     * @memberof EventsResponse
     */
    'pageInfo': PageInfo | null;
}
/**
 * 
 * @export
 * @interface EventsTicketsResponse
 */
export interface EventsTicketsResponse {
    /**
     * 
     * @type {Array<ResponseEventTicketDto>}
     * @memberof EventsTicketsResponse
     */
    'data': Array<ResponseEventTicketDto>;
    /**
     * 
     * @type {PageInfo}
     * @memberof EventsTicketsResponse
     */
    'pageInfo': PageInfo | null;
}
/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * JWT token
     * @type {string}
     * @memberof LoginResponseDto
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface LoginUserDto
 */
export interface LoginUserDto {
    /**
     * 
     * @type {string}
     * @memberof LoginUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginWithAccountDto
 */
export interface LoginWithAccountDto {
    /**
     * Account ID
     * @type {string}
     * @memberof LoginWithAccountDto
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface PageInfo
 */
export interface PageInfo {
    /**
     * 
     * @type {number}
     * @memberof PageInfo
     */
    'totalItems': number;
    /**
     * 
     * @type {number}
     * @memberof PageInfo
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof PageInfo
     */
    'remainingPages': number;
    /**
     * 
     * @type {object}
     * @memberof PageInfo
     */
    'nextPage': object | null;
    /**
     * 
     * @type {object}
     * @memberof PageInfo
     */
    'prevPage': object | null;
}
/**
 * 
 * @export
 * @interface ResponseAccountDto
 */
export interface ResponseAccountDto {
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'corporateName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'fantasyName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'photo': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'segment': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'document': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'documentType': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'neighborhood': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'zipCode': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'complement': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'status': ResponseAccountDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'countryCodePhone': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'areaCodePhone': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountDto
     */
    'deletedAt': string;
}

export const ResponseAccountDtoStatusEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;

export type ResponseAccountDtoStatusEnum = typeof ResponseAccountDtoStatusEnum[keyof typeof ResponseAccountDtoStatusEnum];

/**
 * 
 * @export
 * @interface ResponseAccountUserDto
 */
export interface ResponseAccountUserDto {
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountUserDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountUserDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountUserDto
     */
    'status': ResponseAccountUserDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountUserDto
     */
    'type': ResponseAccountUserDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountUserDto
     */
    'position': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountUserDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAccountUserDto
     */
    'updatedAt': string;
}

export const ResponseAccountUserDtoStatusEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;

export type ResponseAccountUserDtoStatusEnum = typeof ResponseAccountUserDtoStatusEnum[keyof typeof ResponseAccountUserDtoStatusEnum];
export const ResponseAccountUserDtoTypeEnum = {
    Team: 'TEAM',
    Student: 'STUDENT'
} as const;

export type ResponseAccountUserDtoTypeEnum = typeof ResponseAccountUserDtoTypeEnum[keyof typeof ResponseAccountUserDtoTypeEnum];

/**
 * 
 * @export
 * @interface ResponseAllEventParticipantsDto
 */
export interface ResponseAllEventParticipantsDto {
    /**
     * ID do participante (UUID)
     * @type {string}
     * @memberof ResponseAllEventParticipantsDto
     */
    'id': string;
    /**
     * Nome do participante
     * @type {string}
     * @memberof ResponseAllEventParticipantsDto
     */
    'userName': string;
    /**
     * ID do evento associado ao participante (UUID)
     * @type {string}
     * @memberof ResponseAllEventParticipantsDto
     */
    'eventId': string;
    /**
     * Nome do ingresso
     * @type {string}
     * @memberof ResponseAllEventParticipantsDto
     */
    'ticketName': string;
    /**
     * QRcode do participante
     * @type {string}
     * @memberof ResponseAllEventParticipantsDto
     */
    'qrCode': string;
    /**
     * photo path in aws
     * @type {string}
     * @memberof ResponseAllEventParticipantsDto
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface ResponseDocumentAndTermDto
 */
export interface ResponseDocumentAndTermDto {
    /**
     * ID do documento
     * @type {string}
     * @memberof ResponseDocumentAndTermDto
     */
    'id': string;
    /**
     * ID da conta associada ao documento
     * @type {string}
     * @memberof ResponseDocumentAndTermDto
     */
    'accountId': string;
    /**
     * Nome do documento
     * @type {string}
     * @memberof ResponseDocumentAndTermDto
     */
    'name': string;
    /**
     * Caminho do arquivo
     * @type {string}
     * @memberof ResponseDocumentAndTermDto
     */
    'path': string;
    /**
     * Arquivo em formato binário
     * @type {File}
     * @memberof ResponseDocumentAndTermDto
     */
    'file': File;
    /**
     * Data de vencimento
     * @type {string}
     * @memberof ResponseDocumentAndTermDto
     */
    'deadlineAt': string;
    /**
     * Indica se o documento deve ser fechado automaticamente
     * @type {boolean}
     * @memberof ResponseDocumentAndTermDto
     */
    'autoClose': boolean;
    /**
     * Localidade do documento
     * @type {string}
     * @memberof ResponseDocumentAndTermDto
     */
    'locale': string;
    /**
     * Habilitar sequência
     * @type {boolean}
     * @memberof ResponseDocumentAndTermDto
     */
    'sequenceEnabled': boolean;
    /**
     * Intervalo de lembrete
     * @type {string}
     * @memberof ResponseDocumentAndTermDto
     */
    'remindInterval': string;
    /**
     * Bloquear após recusa
     * @type {boolean}
     * @memberof ResponseDocumentAndTermDto
     */
    'blockAfterRefusal': boolean;
    /**
     * Data de criação
     * @type {string}
     * @memberof ResponseDocumentAndTermDto
     */
    'createdAt': string;
    /**
     * Data de atualização
     * @type {string}
     * @memberof ResponseDocumentAndTermDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ResponseDocumentClubDto
 */
export interface ResponseDocumentClubDto {
    /**
     * ID do documento (UUID)
     * @type {string}
     * @memberof ResponseDocumentClubDto
     */
    'id': string;
    /**
     * Número do documento
     * @type {string}
     * @memberof ResponseDocumentClubDto
     */
    'number': string;
    /**
     * Tipo do documento
     * @type {string}
     * @memberof ResponseDocumentClubDto
     */
    'type': string;
    /**
     * Path do documento no computador
     * @type {string}
     * @memberof ResponseDocumentClubDto
     */
    'filePath': string;
}
/**
 * 
 * @export
 * @interface ResponseDocumentDto
 */
export interface ResponseDocumentDto {
    /**
     * ID do documento (UUID)
     * @type {string}
     * @memberof ResponseDocumentDto
     */
    'id': string;
    /**
     * Número do documento
     * @type {string}
     * @memberof ResponseDocumentDto
     */
    'number': string;
    /**
     * Tipo do documento
     * @type {string}
     * @memberof ResponseDocumentDto
     */
    'type': string;
    /**
     * Path do documento no computador
     * @type {string}
     * @memberof ResponseDocumentDto
     */
    'filePath': string;
    /**
     * Path da foto do verso de document
     * @type {string}
     * @memberof ResponseDocumentDto
     */
    'filePathBack': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDocumentDto
     */
    'status': ResponseDocumentDtoStatusEnum;
    /**
     * Data e hora da criação do documento
     * @type {string}
     * @memberof ResponseDocumentDto
     */
    'createdAt': string;
    /**
     * Data e hora da última atualização no documento
     * @type {string}
     * @memberof ResponseDocumentDto
     */
    'updatedAt': string;
    /**
     * Data e hora da exclusão do documento
     * @type {string}
     * @memberof ResponseDocumentDto
     */
    'deletedAt': string;
    /**
     * 
     * @type {Array<UserDocumentResponseDto>}
     * @memberof ResponseDocumentDto
     */
    'userDocument': Array<UserDocumentResponseDto>;
}

export const ResponseDocumentDtoStatusEnum = {
    Sent: 'SENT',
    AwaitingVerification: 'AWAITING_VERIFICATION',
    Verified: 'VERIFIED'
} as const;

export type ResponseDocumentDtoStatusEnum = typeof ResponseDocumentDtoStatusEnum[keyof typeof ResponseDocumentDtoStatusEnum];

/**
 * 
 * @export
 * @interface ResponseEventConfigClubDto
 */
export interface ResponseEventConfigClubDto {
    /**
     * ID
     * @type {string}
     * @memberof ResponseEventConfigClubDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventConfigClubDto
     */
    'type': ResponseEventConfigClubDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventConfigClubDto
     */
    'status': ResponseEventConfigClubDtoStatusEnum;
}

export const ResponseEventConfigClubDtoTypeEnum = {
    PrintAutomatic: 'PRINT_AUTOMATIC',
    SkipStepDocument: 'SKIP_STEP_DOCUMENT',
    Award: 'AWARD'
} as const;

export type ResponseEventConfigClubDtoTypeEnum = typeof ResponseEventConfigClubDtoTypeEnum[keyof typeof ResponseEventConfigClubDtoTypeEnum];
export const ResponseEventConfigClubDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type ResponseEventConfigClubDtoStatusEnum = typeof ResponseEventConfigClubDtoStatusEnum[keyof typeof ResponseEventConfigClubDtoStatusEnum];

/**
 * 
 * @export
 * @interface ResponseEventConfigDto
 */
export interface ResponseEventConfigDto {
    /**
     * ID
     * @type {string}
     * @memberof ResponseEventConfigDto
     */
    'id': string;
    /**
     * ID do evento
     * @type {string}
     * @memberof ResponseEventConfigDto
     */
    'eventId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventConfigDto
     */
    'type': ResponseEventConfigDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventConfigDto
     */
    'status': ResponseEventConfigDtoStatusEnum;
    /**
     * Data de criação do evento
     * @type {string}
     * @memberof ResponseEventConfigDto
     */
    'createdAt': string;
    /**
     * Data de atualização do evento
     * @type {string}
     * @memberof ResponseEventConfigDto
     */
    'updatedAt': string;
    /**
     * Data de exclusão do evento (se aplicável)
     * @type {string}
     * @memberof ResponseEventConfigDto
     */
    'deletedAt': string;
}

export const ResponseEventConfigDtoTypeEnum = {
    PrintAutomatic: 'PRINT_AUTOMATIC',
    SkipStepDocument: 'SKIP_STEP_DOCUMENT',
    Award: 'AWARD'
} as const;

export type ResponseEventConfigDtoTypeEnum = typeof ResponseEventConfigDtoTypeEnum[keyof typeof ResponseEventConfigDtoTypeEnum];
export const ResponseEventConfigDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type ResponseEventConfigDtoStatusEnum = typeof ResponseEventConfigDtoStatusEnum[keyof typeof ResponseEventConfigDtoStatusEnum];

/**
 * 
 * @export
 * @interface ResponseEventDto
 */
export interface ResponseEventDto {
    /**
     * ID do evento (UUID)
     * @type {string}
     * @memberof ResponseEventDto
     */
    'id': string;
    /**
     * ID sequencial do evento
     * @type {number}
     * @memberof ResponseEventDto
     */
    'sequential': number;
    /**
     * ID da conta associada ao evento (UUID)
     * @type {string}
     * @memberof ResponseEventDto
     */
    'accountId': string;
    /**
     * ID do usuário associado ao evento (UUID)
     * @type {string}
     * @memberof ResponseEventDto
     */
    'userId': string;
    /**
     * Nome do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'name': string;
    /**
     * Subtítulo do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'subtitle': string;
    /**
     * URI do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'uri': string;
    /**
     * Tipo do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'type': string;
    /**
     * URL da foto do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'photo': string;
    /**
     * Cor primária do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'colorOne': string;
    /**
     * Cor secundária do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'colorTwo': string;
    /**
     * Descrição do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'description': string;
    /**
     * Informação do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'information': string;
    /**
     * Informações do evento enviados por email
     * @type {string}
     * @memberof ResponseEventDto
     */
    'informationEmail': string;
    /**
     * Vídeo do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'video': string;
    /**
     * Redirecionamento depois que preencher os participantes
     * @type {string}
     * @memberof ResponseEventDto
     */
    'redirect': string;
    /**
     * Link para acionar conversa/grupo no whatsApp na página de obrigado
     * @type {string}
     * @memberof ResponseEventDto
     */
    'whatsappLink': string;
    /**
     * Link para acionar conversa/grupo no telegram na página de obrigado
     * @type {string}
     * @memberof ResponseEventDto
     */
    'telegramLink': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDto
     */
    'status': ResponseEventDtoStatusEnum;
    /**
     * Data e hora de inicio do evento 
     * @type {string}
     * @memberof ResponseEventDto
     */
    'startAt': string;
    /**
     * Data e hora de fim do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'endAt': string;
    /**
     * Data e hora de inicio do evento 
     * @type {string}
     * @memberof ResponseEventDto
     */
    'startPublishAt': string;
    /**
     * Data e hora de fim do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'endPublishAt': string;
    /**
     * Data de criação do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'createdAt': string;
    /**
     * Data de atualização do evento
     * @type {string}
     * @memberof ResponseEventDto
     */
    'updatedAt': string;
    /**
     * Data de exclusão do evento (se aplicável)
     * @type {string}
     * @memberof ResponseEventDto
     */
    'deletedAt': string;
    /**
     * 
     * @type {Array<ResponseEventConfigDto>}
     * @memberof ResponseEventDto
     */
    'eventConfig': Array<ResponseEventConfigDto>;
}

export const ResponseEventDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type ResponseEventDtoStatusEnum = typeof ResponseEventDtoStatusEnum[keyof typeof ResponseEventDtoStatusEnum];

/**
 * 
 * @export
 * @interface ResponseEventParticipantClubDto
 */
export interface ResponseEventParticipantClubDto {
    /**
     * wwwID do participante (UUID)
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'id': string;
    /**
     * ID sequencial do participante
     * @type {number}
     * @memberof ResponseEventParticipantClubDto
     */
    'sequential': number;
    /**
     * ID da conta associada ao participante (UUID)
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'accountId': string;
    /**
     * ID do evento associado ao participante (UUID)
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'eventId': string;
    /**
     * ID do ingresso associada ao participante (UUID)
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'eventTicketId': string;
    /**
     * ID do ingresso associada ao participante (UUID)
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'eventTicketGuestId': string;
    /**
     * ID do usuário associado ao participante
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'status': ResponseEventParticipantClubDtoStatusEnum;
    /**
     * QRcode do participante
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'qrCode': string;
    /**
     * Data de criação do evento
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'createdAt': string;
    /**
     * Data de atualização do evento
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'updatedAt': string;
    /**
     * Data de exclusão do evento (se aplicável)
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'deletedAt': string;
    /**
     * photo path in aws
     * @type {string}
     * @memberof ResponseEventParticipantClubDto
     */
    'path': string;
    /**
     * 
     * @type {EventTicketResponse}
     * @memberof ResponseEventParticipantClubDto
     */
    'eventTicket': EventTicketResponse;
    /**
     * 
     * @type {EventClubResponse}
     * @memberof ResponseEventParticipantClubDto
     */
    'event': EventClubResponse;
    /**
     * 
     * @type {ResponseParticipationUserDTO}
     * @memberof ResponseEventParticipantClubDto
     */
    'user': ResponseParticipationUserDTO;
}

export const ResponseEventParticipantClubDtoStatusEnum = {
    AwaitingPayment: 'AWAITING_PAYMENT',
    CheckInEarly: 'CHECK_IN_EARLY',
    CheckIn: 'CHECK_IN',
    CheckOut: 'CHECK_OUT',
    Canceled: 'CANCELED',
    Enable: 'ENABLE'
} as const;

export type ResponseEventParticipantClubDtoStatusEnum = typeof ResponseEventParticipantClubDtoStatusEnum[keyof typeof ResponseEventParticipantClubDtoStatusEnum];

/**
 * 
 * @export
 * @interface ResponseEventParticipantStatusDto
 */
export interface ResponseEventParticipantStatusDto {
    /**
     * ID do evento (UUID)
     * @type {string}
     * @memberof ResponseEventParticipantStatusDto
     */
    'id': string;
    /**
     * ID do usuário associado ao evento (UUID)
     * @type {string}
     * @memberof ResponseEventParticipantStatusDto
     */
    'eventParticipantId': string;
    /**
     * Event ticket guest status
     * @type {string}
     * @memberof ResponseEventParticipantStatusDto
     */
    'status': ResponseEventParticipantStatusDtoStatusEnum;
    /**
     * Data e hora de inicio do evento
     * @type {string}
     * @memberof ResponseEventParticipantStatusDto
     */
    'createdAt': string;
    /**
     * Data e hora durante a qual o evento foi atualizado
     * @type {string}
     * @memberof ResponseEventParticipantStatusDto
     */
    'updatedAt': string;
    /**
     * Data e hora de fim do evento
     * @type {string}
     * @memberof ResponseEventParticipantStatusDto
     */
    'deletedAt': string;
}

export const ResponseEventParticipantStatusDtoStatusEnum = {
    Checkin: 'CHECKIN',
    Checkout: 'CHECKOUT',
    Pending: 'PENDING'
} as const;

export type ResponseEventParticipantStatusDtoStatusEnum = typeof ResponseEventParticipantStatusDtoStatusEnum[keyof typeof ResponseEventParticipantStatusDtoStatusEnum];

/**
 * 
 * @export
 * @interface ResponseEventTicketDto
 */
export interface ResponseEventTicketDto {
    /**
     * ID do ticket evento (UUID)
     * @type {string}
     * @memberof ResponseEventTicketDto
     */
    'id': string;
    /**
     * ID sequencial do ingresso
     * @type {number}
     * @memberof ResponseEventTicketDto
     */
    'sequential': number;
    /**
     * ID da conta associada ao ticket (UUID)
     * @type {string}
     * @memberof ResponseEventTicketDto
     */
    'accountId': string;
    /**
     * ID do evento associado ao ticket (UUID)
     * @type {string}
     * @memberof ResponseEventTicketDto
     */
    'eventId': string;
    /**
     * Nome do ticket
     * @type {string}
     * @memberof ResponseEventTicketDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof ResponseEventTicketDto
     */
    'price': object;
    /**
     * 
     * @type {object}
     * @memberof ResponseEventTicketDto
     */
    'priceBefore': object;
    /**
     * Status do ingresso
     * @type {string}
     * @memberof ResponseEventTicketDto
     */
    'status': ResponseEventTicketDtoStatusEnum;
    /**
     * Cor do ingresso
     * @type {string}
     * @memberof ResponseEventTicketDto
     */
    'color'?: string;
    /**
     * Número de convidados
     * @type {number}
     * @memberof ResponseEventTicketDto
     */
    'guest'?: number;
    /**
     * Data de criação
     * @type {string}
     * @memberof ResponseEventTicketDto
     */
    'createdAt': string;
    /**
     * Data de atualização
     * @type {string}
     * @memberof ResponseEventTicketDto
     */
    'updatedAt': string;
    /**
     * Data de exclusão (se aplicável)
     * @type {string}
     * @memberof ResponseEventTicketDto
     */
    'deletedAt': string;
}

export const ResponseEventTicketDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type ResponseEventTicketDtoStatusEnum = typeof ResponseEventTicketDtoStatusEnum[keyof typeof ResponseEventTicketDtoStatusEnum];

/**
 * 
 * @export
 * @interface ResponseEventTicketGuestClubDto
 */
export interface ResponseEventTicketGuestClubDto {
    /**
     * testeID da URL ticket evento (UUID)
     * @type {string}
     * @memberof ResponseEventTicketGuestClubDto
     */
    'id': string;
    /**
     * ID da URL ticket evento (UUID)
     * @type {string}
     * @memberof ResponseEventTicketGuestClubDto
     */
    'eventId': string;
    /**
     * ID da URL ticket evento (UUID)
     * @type {string}
     * @memberof ResponseEventTicketGuestClubDto
     */
    'eventTicketId': string;
    /**
     * Data de criação
     * @type {string}
     * @memberof ResponseEventTicketGuestClubDto
     */
    'createdAt': string;
    /**
     * Data de atualização
     * @type {string}
     * @memberof ResponseEventTicketGuestClubDto
     */
    'updatedAt': string;
    /**
     * Data de exclusão (se aplicável)
     * @type {string}
     * @memberof ResponseEventTicketGuestClubDto
     */
    'deletedAt': string;
    /**
     * 
     * @type {EventTicketClubResponse}
     * @memberof ResponseEventTicketGuestClubDto
     */
    'eventTicket': EventTicketClubResponse;
    /**
     * 
     * @type {EventClubResponse}
     * @memberof ResponseEventTicketGuestClubDto
     */
    'event': EventClubResponse;
    /**
     * 
     * @type {Array<EventParticipantClubGuestResponse>}
     * @memberof ResponseEventTicketGuestClubDto
     */
    'eventParticipant': Array<EventParticipantClubGuestResponse>;
}
/**
 * 
 * @export
 * @interface ResponseOTPHashDTO
 */
export interface ResponseOTPHashDTO {
    /**
     * HASH
     * @type {string}
     * @memberof ResponseOTPHashDTO
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface ResponseParticipationUserDTO
 */
export interface ResponseParticipationUserDTO {
    /**
     * ID do participante (UUID)
     * @type {string}
     * @memberof ResponseParticipationUserDTO
     */
    'id': string;
    /**
     * Nome do participante
     * @type {string}
     * @memberof ResponseParticipationUserDTO
     */
    'name': string;
    /**
     * foto do
     * @type {string}
     * @memberof ResponseParticipationUserDTO
     */
    'photo': string;
}
/**
 * 
 * @export
 * @interface ResponseUserDto
 */
export interface ResponseUserDto {
    /**
     * 
     * @type {string}
     * @memberof ResponseUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseUserDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseUserDto
     */
    'status': ResponseUserDtoStatusEnum;
    /**
     * 
     * @type {File}
     * @memberof ResponseUserDto
     */
    'photo'?: File;
    /**
     * 
     * @type {string}
     * @memberof ResponseUserDto
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {Array<AddressResponse>}
     * @memberof ResponseUserDto
     */
    'addresses': Array<AddressResponse>;
    /**
     * 
     * @type {string}
     * @memberof ResponseUserDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseUserDto
     */
    'updatedAt': string;
}

export const ResponseUserDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    WaitingConfirmation: 'WAITING_CONFIRMATION'
} as const;

export type ResponseUserDtoStatusEnum = typeof ResponseUserDtoStatusEnum[keyof typeof ResponseUserDtoStatusEnum];

/**
 * 
 * @export
 * @interface UpdateAccountDto
 */
export interface UpdateAccountDto {
    /**
     * The name of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'name'?: string;
    /**
     * The corporate name of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'corporateName'?: string;
    /**
     * The fantasy name of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'fantasyName'?: string;
    /**
     * The segment of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'segment'?: string;
    /**
     * The document number of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'document'?: string;
    /**
     * The type of document (CNPJ)
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'documentType'?: string;
    /**
     * The domain of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'domain'?: string;
    /**
     * The email of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'email'?: string;
    /**
     * The street address of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'street'?: string;
    /**
     * The state of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'state'?: string;
    /**
     * The city of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'city'?: string;
    /**
     * The neighborhood of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'neighborhood'?: string;
    /**
     * The country of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'country'?: string;
    /**
     * The ZIP code of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'zipCode'?: string;
    /**
     * The complement of the address
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'complement'?: string;
    /**
     * The status of the account
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'status'?: UpdateAccountDtoStatusEnum;
    /**
     * The country code of the phone number
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'countryCodePhone'?: string;
    /**
     * The area code of the phone number
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'areaCodePhone'?: string;
    /**
     * The phone number
     * @type {string}
     * @memberof UpdateAccountDto
     */
    'phoneNumber'?: string;
}

export const UpdateAccountDtoStatusEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;

export type UpdateAccountDtoStatusEnum = typeof UpdateAccountDtoStatusEnum[keyof typeof UpdateAccountDtoStatusEnum];

/**
 * 
 * @export
 * @interface UpdateAccountUserDto
 */
export interface UpdateAccountUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountUserDto
     */
    'status': UpdateAccountUserDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountUserDto
     */
    'type': UpdateAccountUserDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountUserDto
     */
    'position': string;
}

export const UpdateAccountUserDtoStatusEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;

export type UpdateAccountUserDtoStatusEnum = typeof UpdateAccountUserDtoStatusEnum[keyof typeof UpdateAccountUserDtoStatusEnum];
export const UpdateAccountUserDtoTypeEnum = {
    Team: 'TEAM',
    Student: 'STUDENT'
} as const;

export type UpdateAccountUserDtoTypeEnum = typeof UpdateAccountUserDtoTypeEnum[keyof typeof UpdateAccountUserDtoTypeEnum];

/**
 * 
 * @export
 * @interface UpdateAddressDto
 */
export interface UpdateAddressDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'country': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAddressDto
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface UpdateDocumentAndTermDto
 */
export interface UpdateDocumentAndTermDto {
    /**
     * Novo nome do documento (opcional)
     * @type {string}
     * @memberof UpdateDocumentAndTermDto
     */
    'name': string;
    /**
     * Novo caminho do arquivo (opcional)
     * @type {string}
     * @memberof UpdateDocumentAndTermDto
     */
    'path': string;
    /**
     * Novo arquivo em formato binário (opcional)
     * @type {File}
     * @memberof UpdateDocumentAndTermDto
     */
    'file': File;
    /**
     * Nova data de vencimento (opcional)
     * @type {string}
     * @memberof UpdateDocumentAndTermDto
     */
    'deadlineAt': string;
    /**
     * Indica se o documento deve ser fechado automaticamente (opcional)
     * @type {boolean}
     * @memberof UpdateDocumentAndTermDto
     */
    'autoClose': boolean;
    /**
     * Nova localidade do documento (opcional)
     * @type {string}
     * @memberof UpdateDocumentAndTermDto
     */
    'locale': string;
    /**
     * Habilitar sequência (opcional)
     * @type {boolean}
     * @memberof UpdateDocumentAndTermDto
     */
    'sequenceEnabled': boolean;
    /**
     * Novo intervalo de lembrete (opcional)
     * @type {string}
     * @memberof UpdateDocumentAndTermDto
     */
    'remindInterval': string;
    /**
     * Bloquear após recusa (opcional)
     * @type {boolean}
     * @memberof UpdateDocumentAndTermDto
     */
    'blockAfterRefusal': boolean;
}
/**
 * 
 * @export
 * @interface UpdateDocumentDto
 */
export interface UpdateDocumentDto {
    /**
     * Número do documento
     * @type {string}
     * @memberof UpdateDocumentDto
     */
    'number': string;
    /**
     * Tipo do documento
     * @type {string}
     * @memberof UpdateDocumentDto
     */
    'type': string;
    /**
     * Path do documento no computador
     * @type {string}
     * @memberof UpdateDocumentDto
     */
    'filePath': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDocumentDto
     */
    'status': UpdateDocumentDtoStatusEnum;
    /**
     * Data e hora da última atualização no documento
     * @type {string}
     * @memberof UpdateDocumentDto
     */
    'updatedAt': string;
    /**
     * Data e hora da exclusão do documento
     * @type {string}
     * @memberof UpdateDocumentDto
     */
    'deletedAt': string;
    /**
     * 
     * @type {UpdateUserDocumentDto}
     * @memberof UpdateDocumentDto
     */
    'userDocument': UpdateUserDocumentDto;
}

export const UpdateDocumentDtoStatusEnum = {
    Sent: 'SENT',
    AwaitingVerification: 'AWAITING_VERIFICATION',
    Verified: 'VERIFIED'
} as const;

export type UpdateDocumentDtoStatusEnum = typeof UpdateDocumentDtoStatusEnum[keyof typeof UpdateDocumentDtoStatusEnum];

/**
 * 
 * @export
 * @interface UpdateEventConfigDto
 */
export interface UpdateEventConfigDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateEventConfigDto
     */
    'type': UpdateEventConfigDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventConfigDto
     */
    'status': UpdateEventConfigDtoStatusEnum;
}

export const UpdateEventConfigDtoTypeEnum = {
    PrintAutomatic: 'PRINT_AUTOMATIC',
    SkipStepDocument: 'SKIP_STEP_DOCUMENT',
    Award: 'AWARD'
} as const;

export type UpdateEventConfigDtoTypeEnum = typeof UpdateEventConfigDtoTypeEnum[keyof typeof UpdateEventConfigDtoTypeEnum];
export const UpdateEventConfigDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type UpdateEventConfigDtoStatusEnum = typeof UpdateEventConfigDtoStatusEnum[keyof typeof UpdateEventConfigDtoStatusEnum];

/**
 * 
 * @export
 * @interface UpdateEventDto
 */
export interface UpdateEventDto {
    /**
     * Novo nome do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'name': string;
    /**
     * Novo subtítulo do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'subtitle': string;
    /**
     * Nova URI do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'uri': string;
    /**
     * Novo tipo do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'type': string;
    /**
     * Nova cor primária do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'colorOne': string;
    /**
     * Nova cor secundária do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'colorTwo': string;
    /**
     * Nova descrição do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'description': string;
    /**
     * Informação do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'information': string;
    /**
     * Informações do evento enviados por email
     * @type {string}
     * @memberof UpdateEventDto
     */
    'informationEmail': string;
    /**
     * Vídeo do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'video': string;
    /**
     * Redirecionamento depois que preencher os participantes
     * @type {string}
     * @memberof UpdateEventDto
     */
    'redirect': string;
    /**
     * Link para acionar consversa/grupo no whatsapp na página de obrigado
     * @type {string}
     * @memberof UpdateEventDto
     */
    'whatsappLink': string;
    /**
     * Link para acionar consversa/grupo no telegram na página de obrigado
     * @type {string}
     * @memberof UpdateEventDto
     */
    'telegramLink': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventDto
     */
    'status': UpdateEventDtoStatusEnum;
    /**
     * Data e hora de inicio do evento 
     * @type {string}
     * @memberof UpdateEventDto
     */
    'startAt': string;
    /**
     * Data e hora de fim do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'endAt': string;
    /**
     * Data e hora de inicio do evento 
     * @type {string}
     * @memberof UpdateEventDto
     */
    'startPublishAt': string;
    /**
     * Data e hora de fim do evento
     * @type {string}
     * @memberof UpdateEventDto
     */
    'endPublishAt': string;
}

export const UpdateEventDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type UpdateEventDtoStatusEnum = typeof UpdateEventDtoStatusEnum[keyof typeof UpdateEventDtoStatusEnum];

/**
 * 
 * @export
 * @interface UpdateEventParticipantDto
 */
export interface UpdateEventParticipantDto {
    /**
     * ID do ingresso associada ao participante (UUID)
     * @type {string}
     * @memberof UpdateEventParticipantDto
     */
    'eventTicketId': string;
    /**
     * ID do usuário participante
     * @type {string}
     * @memberof UpdateEventParticipantDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventParticipantDto
     */
    'status': UpdateEventParticipantDtoStatusEnum;
    /**
     * Participant synchronized with local db
     * @type {boolean}
     * @memberof UpdateEventParticipantDto
     */
    'isSynchronized': boolean;
}

export const UpdateEventParticipantDtoStatusEnum = {
    AwaitingPayment: 'AWAITING_PAYMENT',
    CheckInEarly: 'CHECK_IN_EARLY',
    CheckIn: 'CHECK_IN',
    CheckOut: 'CHECK_OUT',
    Canceled: 'CANCELED',
    Enable: 'ENABLE'
} as const;

export type UpdateEventParticipantDtoStatusEnum = typeof UpdateEventParticipantDtoStatusEnum[keyof typeof UpdateEventParticipantDtoStatusEnum];

/**
 * 
 * @export
 * @interface UpdateEventParticipantStatusDto
 */
export interface UpdateEventParticipantStatusDto {
    /**
     * Status do usuário no evento
     * @type {string}
     * @memberof UpdateEventParticipantStatusDto
     */
    'status': UpdateEventParticipantStatusDtoStatusEnum;
}

export const UpdateEventParticipantStatusDtoStatusEnum = {
    Checkin: 'CHECKIN',
    Checkout: 'CHECKOUT',
    Pending: 'PENDING'
} as const;

export type UpdateEventParticipantStatusDtoStatusEnum = typeof UpdateEventParticipantStatusDtoStatusEnum[keyof typeof UpdateEventParticipantStatusDtoStatusEnum];

/**
 * 
 * @export
 * @interface UpdateEventTicketDto
 */
export interface UpdateEventTicketDto {
    /**
     * Nome do participante
     * @type {string}
     * @memberof UpdateEventTicketDto
     */
    'name': string;
    /**
     * Preço do ingresso
     * @type {number}
     * @memberof UpdateEventTicketDto
     */
    'price': number;
    /**
     * Preço antes do desconto
     * @type {number}
     * @memberof UpdateEventTicketDto
     */
    'priceBefore': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventTicketDto
     */
    'status': UpdateEventTicketDtoStatusEnum;
    /**
     * Cor do ingresso
     * @type {string}
     * @memberof UpdateEventTicketDto
     */
    'color'?: string;
    /**
     * Número de convidados
     * @type {number}
     * @memberof UpdateEventTicketDto
     */
    'guest'?: number;
}

export const UpdateEventTicketDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type UpdateEventTicketDtoStatusEnum = typeof UpdateEventTicketDtoStatusEnum[keyof typeof UpdateEventTicketDtoStatusEnum];

/**
 * 
 * @export
 * @interface UpdateUserDocumentDto
 */
export interface UpdateUserDocumentDto {
    /**
     * URL da foto
     * @type {string}
     * @memberof UpdateUserDocumentDto
     */
    'photo'?: string;
    /**
     * Indica se está ativo
     * @type {boolean}
     * @memberof UpdateUserDocumentDto
     */
    'isActive'?: boolean;
    /**
     * Data e hora da última atualização no documento
     * @type {string}
     * @memberof UpdateUserDocumentDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'status': UpdateUserDtoStatusEnum;
}

export const UpdateUserDtoStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    WaitingConfirmation: 'WAITING_CONFIRMATION'
} as const;

export type UpdateUserDtoStatusEnum = typeof UpdateUserDtoStatusEnum[keyof typeof UpdateUserDtoStatusEnum];

/**
 * 
 * @export
 * @interface UserDocumentClubResponseDto
 */
export interface UserDocumentClubResponseDto {
    /**
     * 
     * @type {ResponseDocumentClubDto}
     * @memberof UserDocumentClubResponseDto
     */
    'document': ResponseDocumentClubDto;
}
/**
 * 
 * @export
 * @interface UserDocumentResponseDto
 */
export interface UserDocumentResponseDto {
    /**
     * ID do UserDocument (UUID)
     * @type {string}
     * @memberof UserDocumentResponseDto
     */
    'id': string;
    /**
     * ID do usuário (UUID)
     * @type {string}
     * @memberof UserDocumentResponseDto
     */
    'userId': string;
    /**
     * ID do documento (UUID)
     * @type {string}
     * @memberof UserDocumentResponseDto
     */
    'documentId': string;
    /**
     * Indica se está ativo
     * @type {boolean}
     * @memberof UserDocumentResponseDto
     */
    'isActive': boolean;
    /**
     * URL da foto
     * @type {string}
     * @memberof UserDocumentResponseDto
     */
    'photo': string;
    /**
     * Data e hora da criação do UserDocument
     * @type {string}
     * @memberof UserDocumentResponseDto
     */
    'createdAt': string;
    /**
     * Data e hora da última atualização no UserDocument
     * @type {string}
     * @memberof UserDocumentResponseDto
     */
    'updatedAt': string;
    /**
     * Data e hora da exclusão do UserDocument
     * @type {string}
     * @memberof UserDocumentResponseDto
     */
    'deletedAt': string;
}
/**
 * 
 * @export
 * @interface UserFaceGuestClubResponse
 */
export interface UserFaceGuestClubResponse {
    /**
     * 
     * @type {string}
     * @memberof UserFaceGuestClubResponse
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserGuestClubResponse
 */
export interface UserGuestClubResponse {
    /**
     * 
     * @type {string}
     * @memberof UserGuestClubResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGuestClubResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGuestClubResponse
     */
    'photo'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGuestClubResponse
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {Array<UserFaceGuestClubResponse>}
     * @memberof UserGuestClubResponse
     */
    'userFaces'?: Array<UserFaceGuestClubResponse>;
    /**
     * 
     * @type {Array<UserDocumentClubResponseDto>}
     * @memberof UserGuestClubResponse
     */
    'documents'?: Array<UserDocumentClubResponseDto>;
}
/**
 * 
 * @export
 * @interface UserInitialSubscribe
 */
export interface UserInitialSubscribe {
    /**
     * 
     * @type {string}
     * @memberof UserInitialSubscribe
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserInitialSubscribe
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserInitialSubscribe
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserInitialSubscribe
     */
    'countryCodePhone': string;
    /**
     * 
     * @type {string}
     * @memberof UserInitialSubscribe
     */
    'areaCodePhone': string;
    /**
     * 
     * @type {string}
     * @memberof UserInitialSubscribe
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof UserInitialSubscribe
     */
    'dateOfBirth': string;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'status'?: UserResponseStatusEnum;
    /**
     * 
     * @type {File}
     * @memberof UserResponse
     */
    'photo'?: File;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'countryCodePhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'areaCodePhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {Array<AddressResponse>}
     * @memberof UserResponse
     */
    'addresses'?: Array<AddressResponse>;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'updatedAt'?: string;
}

export const UserResponseStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    WaitingConfirmation: 'WAITING_CONFIRMATION'
} as const;

export type UserResponseStatusEnum = typeof UserResponseStatusEnum[keyof typeof UserResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserWithoutPassword
 */
export interface UserWithoutPassword {
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    'status': UserWithoutPasswordStatusEnum;
    /**
     * 
     * @type {File}
     * @memberof UserWithoutPassword
     */
    'photo'?: File;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    'countryCodePhone': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    'areaCodePhone': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {Array<AddressResponse>}
     * @memberof UserWithoutPassword
     */
    'addresses': Array<AddressResponse>;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    'updatedAt': string;
}

export const UserWithoutPasswordStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    WaitingConfirmation: 'WAITING_CONFIRMATION'
} as const;

export type UserWithoutPasswordStatusEnum = typeof UserWithoutPasswordStatusEnum[keyof typeof UserWithoutPasswordStatusEnum];

/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 
     * @type {Array<UserWithoutPassword>}
     * @memberof UsersResponse
     */
    'data': Array<UserWithoutPassword>;
    /**
     * 
     * @type {PageInfo}
     * @memberof UsersResponse
     */
    'pageInfo': PageInfo | null;
}
/**
 * 
 * @export
 * @interface ValidateOtpDto
 */
export interface ValidateOtpDto {
    /**
     * Senha OTP
     * @type {string}
     * @memberof ValidateOtpDto
     */
    'number': string;
    /**
     * HASH
     * @type {string}
     * @memberof ValidateOtpDto
     */
    'hash': string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new account
         * @param {CreateAccountDto} createAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerCreate: async (createAccountDto: CreateAccountDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountDto' is not null or undefined
            assertParamExists('accountControllerCreate', 'createAccountDto', createAccountDto)
            const localVarPath = `/account/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all accounts
         * @param {string} [name] 
         * @param {string} [corporateName] 
         * @param {string} [fantasyName] 
         * @param {string} [document] 
         * @param {AccountControllerFindAllStatusEnum} [status] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindAll: async (name?: string, corporateName?: string, fantasyName?: string, document?: string, status?: AccountControllerFindAllStatusEnum, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (corporateName !== undefined) {
                localVarQueryParameter['corporateName'] = corporateName;
            }

            if (fantasyName !== undefined) {
                localVarQueryParameter['fantasyName'] = fantasyName;
            }

            if (document !== undefined) {
                localVarQueryParameter['document'] = document;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account by ID
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerFindOne', 'id', id)
            const localVarPath = `/account/v1/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an account
         * @param {string} id Account ID
         * @param {UpdateAccountDto} updateAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdate: async (id: string, updateAccountDto: UpdateAccountDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerUpdate', 'id', id)
            // verify required parameter 'updateAccountDto' is not null or undefined
            assertParamExists('accountControllerUpdate', 'updateAccountDto', updateAccountDto)
            const localVarPath = `/account/v1/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit photo/avatar a account
         * @param {string} id Account Id
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUploadPhoto: async (id: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerUploadPhoto', 'id', id)
            const localVarPath = `/account/v1/account/{id}/photo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new account
         * @param {CreateAccountDto} createAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerCreate(createAccountDto: CreateAccountDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerCreate(createAccountDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all accounts
         * @param {string} [name] 
         * @param {string} [corporateName] 
         * @param {string} [fantasyName] 
         * @param {string} [document] 
         * @param {AccountControllerFindAllStatusEnum} [status] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindAll(name?: string, corporateName?: string, fantasyName?: string, document?: string, status?: AccountControllerFindAllStatusEnum, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindAll(name, corporateName, fantasyName, document, status, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get account by ID
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an account
         * @param {string} id Account ID
         * @param {UpdateAccountDto} updateAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdate(id: string, updateAccountDto: UpdateAccountDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdate(id, updateAccountDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit photo/avatar a account
         * @param {string} id Account Id
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUploadPhoto(id: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUploadPhoto(id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new account
         * @param {CreateAccountDto} createAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerCreate(createAccountDto: CreateAccountDto, options?: any): AxiosPromise<ResponseAccountDto> {
            return localVarFp.accountControllerCreate(createAccountDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all accounts
         * @param {string} [name] 
         * @param {string} [corporateName] 
         * @param {string} [fantasyName] 
         * @param {string} [document] 
         * @param {AccountControllerFindAllStatusEnum} [status] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindAll(name?: string, corporateName?: string, fantasyName?: string, document?: string, status?: AccountControllerFindAllStatusEnum, page?: number, perPage?: number, options?: any): AxiosPromise<AccountsResponse> {
            return localVarFp.accountControllerFindAll(name, corporateName, fantasyName, document, status, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account by ID
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOne(id: string, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.accountControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an account
         * @param {string} id Account ID
         * @param {UpdateAccountDto} updateAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdate(id: string, updateAccountDto: UpdateAccountDto, options?: any): AxiosPromise<void> {
            return localVarFp.accountControllerUpdate(id, updateAccountDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit photo/avatar a account
         * @param {string} id Account Id
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUploadPhoto(id: string, file?: File, options?: any): AxiosPromise<void> {
            return localVarFp.accountControllerUploadPhoto(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Create a new account
     * @param {CreateAccountDto} createAccountDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerCreate(createAccountDto: CreateAccountDto, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerCreate(createAccountDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all accounts
     * @param {string} [name] 
     * @param {string} [corporateName] 
     * @param {string} [fantasyName] 
     * @param {string} [document] 
     * @param {AccountControllerFindAllStatusEnum} [status] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindAll(name?: string, corporateName?: string, fantasyName?: string, document?: string, status?: AccountControllerFindAllStatusEnum, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindAll(name, corporateName, fantasyName, document, status, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account by ID
     * @param {string} id Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an account
     * @param {string} id Account ID
     * @param {UpdateAccountDto} updateAccountDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerUpdate(id: string, updateAccountDto: UpdateAccountDto, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerUpdate(id, updateAccountDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit photo/avatar a account
     * @param {string} id Account Id
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerUploadPhoto(id: string, file?: File, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerUploadPhoto(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AccountControllerFindAllStatusEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;
export type AccountControllerFindAllStatusEnum = typeof AccountControllerFindAllStatusEnum[keyof typeof AccountControllerFindAllStatusEnum];


/**
 * AccountUsersApi - axios parameter creator
 * @export
 */
export const AccountUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an account user
         * @param {CreateAccountUserDto} createAccountUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUserControllerCreate: async (createAccountUserDto: CreateAccountUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountUserDto' is not null or undefined
            assertParamExists('accountUserControllerCreate', 'createAccountUserDto', createAccountUserDto)
            const localVarPath = `/account/v1/account-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Ger an account user with filter
         * @param {string} [accountId] 
         * @param {string} [userId] 
         * @param {AccountUserControllerFindAllTypeEnum} [type] 
         * @param {AccountUserControllerFindAllStatusEnum} [status] 
         * @param {string} [position] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUserControllerFindAll: async (accountId?: string, userId?: string, type?: AccountUserControllerFindAllTypeEnum, status?: AccountUserControllerFindAllStatusEnum, position?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/v1/account-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an account user especific
         * @param {string} id Account User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUserControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountUserControllerFindOne', 'id', id)
            const localVarPath = `/account/v1/account-user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an account user
         * @param {string} id Account User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUserControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountUserControllerRemove', 'id', id)
            const localVarPath = `/account/v1/account-user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Account User
         * @param {string} id Account User ID
         * @param {UpdateAccountUserDto} updateAccountUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUserControllerUpdate: async (id: string, updateAccountUserDto: UpdateAccountUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountUserControllerUpdate', 'id', id)
            // verify required parameter 'updateAccountUserDto' is not null or undefined
            assertParamExists('accountUserControllerUpdate', 'updateAccountUserDto', updateAccountUserDto)
            const localVarPath = `/account/v1/account-user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountUsersApi - functional programming interface
 * @export
 */
export const AccountUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an account user
         * @param {CreateAccountUserDto} createAccountUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountUserControllerCreate(createAccountUserDto: CreateAccountUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountUserControllerCreate(createAccountUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Ger an account user with filter
         * @param {string} [accountId] 
         * @param {string} [userId] 
         * @param {AccountUserControllerFindAllTypeEnum} [type] 
         * @param {AccountUserControllerFindAllStatusEnum} [status] 
         * @param {string} [position] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountUserControllerFindAll(accountId?: string, userId?: string, type?: AccountUserControllerFindAllTypeEnum, status?: AccountUserControllerFindAllStatusEnum, position?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountUserControllerFindAll(accountId, userId, type, status, position, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an account user especific
         * @param {string} id Account User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountUserControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountUserControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an account user
         * @param {string} id Account User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountUserControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountUserControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an Account User
         * @param {string} id Account User ID
         * @param {UpdateAccountUserDto} updateAccountUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountUserControllerUpdate(id: string, updateAccountUserDto: UpdateAccountUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountUserControllerUpdate(id, updateAccountUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountUsersApi - factory interface
 * @export
 */
export const AccountUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountUsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an account user
         * @param {CreateAccountUserDto} createAccountUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUserControllerCreate(createAccountUserDto: CreateAccountUserDto, options?: any): AxiosPromise<ResponseAccountUserDto> {
            return localVarFp.accountUserControllerCreate(createAccountUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Ger an account user with filter
         * @param {string} [accountId] 
         * @param {string} [userId] 
         * @param {AccountUserControllerFindAllTypeEnum} [type] 
         * @param {AccountUserControllerFindAllStatusEnum} [status] 
         * @param {string} [position] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUserControllerFindAll(accountId?: string, userId?: string, type?: AccountUserControllerFindAllTypeEnum, status?: AccountUserControllerFindAllStatusEnum, position?: string, page?: number, perPage?: number, options?: any): AxiosPromise<AccountsUserResponse> {
            return localVarFp.accountUserControllerFindAll(accountId, userId, type, status, position, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an account user especific
         * @param {string} id Account User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUserControllerFindOne(id: string, options?: any): AxiosPromise<AccountUserResponse> {
            return localVarFp.accountUserControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an account user
         * @param {string} id Account User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUserControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountUserControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an Account User
         * @param {string} id Account User ID
         * @param {UpdateAccountUserDto} updateAccountUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUserControllerUpdate(id: string, updateAccountUserDto: UpdateAccountUserDto, options?: any): AxiosPromise<AccountUserResponse> {
            return localVarFp.accountUserControllerUpdate(id, updateAccountUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountUsersApi - object-oriented interface
 * @export
 * @class AccountUsersApi
 * @extends {BaseAPI}
 */
export class AccountUsersApi extends BaseAPI {
    /**
     * 
     * @summary Create an account user
     * @param {CreateAccountUserDto} createAccountUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsersApi
     */
    public accountUserControllerCreate(createAccountUserDto: CreateAccountUserDto, options?: AxiosRequestConfig) {
        return AccountUsersApiFp(this.configuration).accountUserControllerCreate(createAccountUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Ger an account user with filter
     * @param {string} [accountId] 
     * @param {string} [userId] 
     * @param {AccountUserControllerFindAllTypeEnum} [type] 
     * @param {AccountUserControllerFindAllStatusEnum} [status] 
     * @param {string} [position] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsersApi
     */
    public accountUserControllerFindAll(accountId?: string, userId?: string, type?: AccountUserControllerFindAllTypeEnum, status?: AccountUserControllerFindAllStatusEnum, position?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AccountUsersApiFp(this.configuration).accountUserControllerFindAll(accountId, userId, type, status, position, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an account user especific
     * @param {string} id Account User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsersApi
     */
    public accountUserControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return AccountUsersApiFp(this.configuration).accountUserControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an account user
     * @param {string} id Account User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsersApi
     */
    public accountUserControllerRemove(id: string, options?: AxiosRequestConfig) {
        return AccountUsersApiFp(this.configuration).accountUserControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an Account User
     * @param {string} id Account User ID
     * @param {UpdateAccountUserDto} updateAccountUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsersApi
     */
    public accountUserControllerUpdate(id: string, updateAccountUserDto: UpdateAccountUserDto, options?: AxiosRequestConfig) {
        return AccountUsersApiFp(this.configuration).accountUserControllerUpdate(id, updateAccountUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AccountUserControllerFindAllTypeEnum = {
    Team: 'TEAM',
    Student: 'STUDENT'
} as const;
export type AccountUserControllerFindAllTypeEnum = typeof AccountUserControllerFindAllTypeEnum[keyof typeof AccountUserControllerFindAllTypeEnum];
/**
 * @export
 */
export const AccountUserControllerFindAllStatusEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;
export type AccountUserControllerFindAllStatusEnum = typeof AccountUserControllerFindAllStatusEnum[keyof typeof AccountUserControllerFindAllStatusEnum];


/**
 * AddressUserApi - axios parameter creator
 * @export
 */
export const AddressUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create address for user
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerCreate: async (createAddressDto: CreateAddressDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAddressDto' is not null or undefined
            assertParamExists('addressControllerCreate', 'createAddressDto', createAddressDto)
            const localVarPath = `/address/v1/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get address the user with filter
         * @param {string} userId 
         * @param {string} [filter] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerFindAll: async (userId: string, filter?: string, perPage?: any, page?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addressControllerFindAll', 'userId', userId)
            const localVarPath = `/address/v1/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get address the user with ID
         * @param {string} id Address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressControllerFindOne', 'id', id)
            const localVarPath = `/address/v1/address/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete address the user with ID
         * @param {string} id Address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressControllerRemove', 'id', id)
            const localVarPath = `/address/v1/address/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update address the user with ID
         * @param {string} id Address ID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerUpdate: async (id: string, updateAddressDto: UpdateAddressDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressControllerUpdate', 'id', id)
            // verify required parameter 'updateAddressDto' is not null or undefined
            assertParamExists('addressControllerUpdate', 'updateAddressDto', updateAddressDto)
            const localVarPath = `/address/v1/address/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressUserApi - functional programming interface
 * @export
 */
export const AddressUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create address for user
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerCreate(createAddressDto: CreateAddressDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerCreate(createAddressDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get address the user with filter
         * @param {string} userId 
         * @param {string} [filter] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerFindAll(userId: string, filter?: string, perPage?: any, page?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerFindAll(userId, filter, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get address the user with ID
         * @param {string} id Address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete address the user with ID
         * @param {string} id Address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update address the user with ID
         * @param {string} id Address ID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerUpdate(id: string, updateAddressDto: UpdateAddressDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerUpdate(id, updateAddressDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressUserApi - factory interface
 * @export
 */
export const AddressUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Create address for user
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerCreate(createAddressDto: CreateAddressDto, options?: any): AxiosPromise<AddressResponse> {
            return localVarFp.addressControllerCreate(createAddressDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get address the user with filter
         * @param {string} userId 
         * @param {string} [filter] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerFindAll(userId: string, filter?: string, perPage?: any, page?: any, options?: any): AxiosPromise<Array<AddressesResponse>> {
            return localVarFp.addressControllerFindAll(userId, filter, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get address the user with ID
         * @param {string} id Address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerFindOne(id: string, options?: any): AxiosPromise<AddressResponse> {
            return localVarFp.addressControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete address the user with ID
         * @param {string} id Address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerRemove(id: string, options?: any): AxiosPromise<DeleteAddressResponse> {
            return localVarFp.addressControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update address the user with ID
         * @param {string} id Address ID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerUpdate(id: string, updateAddressDto: UpdateAddressDto, options?: any): AxiosPromise<AddressResponse> {
            return localVarFp.addressControllerUpdate(id, updateAddressDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressUserApi - object-oriented interface
 * @export
 * @class AddressUserApi
 * @extends {BaseAPI}
 */
export class AddressUserApi extends BaseAPI {
    /**
     * 
     * @summary Create address for user
     * @param {CreateAddressDto} createAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressUserApi
     */
    public addressControllerCreate(createAddressDto: CreateAddressDto, options?: AxiosRequestConfig) {
        return AddressUserApiFp(this.configuration).addressControllerCreate(createAddressDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get address the user with filter
     * @param {string} userId 
     * @param {string} [filter] 
     * @param {any} [perPage] 
     * @param {any} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressUserApi
     */
    public addressControllerFindAll(userId: string, filter?: string, perPage?: any, page?: any, options?: AxiosRequestConfig) {
        return AddressUserApiFp(this.configuration).addressControllerFindAll(userId, filter, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get address the user with ID
     * @param {string} id Address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressUserApi
     */
    public addressControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return AddressUserApiFp(this.configuration).addressControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete address the user with ID
     * @param {string} id Address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressUserApi
     */
    public addressControllerRemove(id: string, options?: AxiosRequestConfig) {
        return AddressUserApiFp(this.configuration).addressControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update address the user with ID
     * @param {string} id Address ID
     * @param {UpdateAddressDto} updateAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressUserApi
     */
    public addressControllerUpdate(id: string, updateAddressDto: UpdateAddressDto, options?: AxiosRequestConfig) {
        return AddressUserApiFp(this.configuration).addressControllerUpdate(id, updateAddressDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {LoginUserDto} loginUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginUserDto: LoginUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginUserDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginUserDto', loginUserDto)
            const localVarPath = `/auth/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login with Account using JWT
         * @param {LoginWithAccountDto} loginWithAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithAccount: async (loginWithAccountDto: LoginWithAccountDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginWithAccountDto' is not null or undefined
            assertParamExists('authControllerLoginWithAccount', 'loginWithAccountDto', loginWithAccountDto)
            const localVarPath = `/auth/v1/auth/login-with-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginWithAccountDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {LoginUserDto} loginUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginUserDto: LoginUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login with Account using JWT
         * @param {LoginWithAccountDto} loginWithAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginWithAccount(loginWithAccountDto: LoginWithAccountDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginWithAccount(loginWithAccountDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {LoginUserDto} loginUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginUserDto: LoginUserDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.authControllerLogin(loginUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login with Account using JWT
         * @param {LoginWithAccountDto} loginWithAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithAccount(loginWithAccountDto: LoginWithAccountDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerLoginWithAccount(loginWithAccountDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Login
     * @param {LoginUserDto} loginUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginUserDto: LoginUserDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login with Account using JWT
     * @param {LoginWithAccountDto} loginWithAccountDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLoginWithAccount(loginWithAccountDto: LoginWithAccountDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLoginWithAccount(loginWithAccountDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClubEventParticipantClubApi - axios parameter creator
 * @export
 */
export const ClubEventParticipantClubApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an participant
         * @param {string} eventTicketGuestId Event Ticket Guest ID
         * @param {CreateEventParticipantClubDto} createEventParticipantClubDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantClubControllerCreate: async (eventTicketGuestId: string, createEventParticipantClubDto: CreateEventParticipantClubDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventTicketGuestId' is not null or undefined
            assertParamExists('eventParticipantClubControllerCreate', 'eventTicketGuestId', eventTicketGuestId)
            // verify required parameter 'createEventParticipantClubDto' is not null or undefined
            assertParamExists('eventParticipantClubControllerCreate', 'createEventParticipantClubDto', createEventParticipantClubDto)
            const localVarPath = `/event/club/v1/event-participant/{eventTicketGuestId}`
                .replace(`{${"eventTicketGuestId"}}`, encodeURIComponent(String(eventTicketGuestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventParticipantClubDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all participation by user
         * @param {string} [eventId] Event ID
         * @param {number} [sequential] 
         * @param {string} [qrCode] 
         * @param {Array<any>} [status] Array de status (opcional)
         * @param {string} [name] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {Array<any>} [ticketsId] Array de ticketsIds (opcional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantClubControllerFindAll: async (eventId?: string, sequential?: number, qrCode?: string, status?: Array<any>, name?: string, perPage?: any, page?: any, ticketsId?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event/club/v1/event-participant/user-tickets`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sequential !== undefined) {
                localVarQueryParameter['sequential'] = sequential;
            }

            if (qrCode !== undefined) {
                localVarQueryParameter['qrCode'] = qrCode;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (ticketsId) {
                localVarQueryParameter['ticketsId'] = ticketsId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get unique participation by user
         * @param {string} id Event User Participant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantClubControllerFindOneParticipation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventParticipantClubControllerFindOneParticipation', 'id', id)
            const localVarPath = `/event/club/v1/event-participant/user-tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit photo/avatar for a event participant
         * @param {string} id Event Participant ID
         * @param {File} photo Binary data of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantClubControllerUploadPhoto: async (id: string, photo: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventParticipantClubControllerUploadPhoto', 'id', id)
            // verify required parameter 'photo' is not null or undefined
            assertParamExists('eventParticipantClubControllerUploadPhoto', 'photo', photo)
            const localVarPath = `/event/club/v1/event-participant/{id}/photo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (photo !== undefined) { 
                localVarFormParams.append('photo', photo as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClubEventParticipantClubApi - functional programming interface
 * @export
 */
export const ClubEventParticipantClubApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClubEventParticipantClubApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an participant
         * @param {string} eventTicketGuestId Event Ticket Guest ID
         * @param {CreateEventParticipantClubDto} createEventParticipantClubDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipantClubControllerCreate(eventTicketGuestId: string, createEventParticipantClubDto: CreateEventParticipantClubDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventParticipantClubGuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipantClubControllerCreate(eventTicketGuestId, createEventParticipantClubDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all participation by user
         * @param {string} [eventId] Event ID
         * @param {number} [sequential] 
         * @param {string} [qrCode] 
         * @param {Array<any>} [status] Array de status (opcional)
         * @param {string} [name] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {Array<any>} [ticketsId] Array de ticketsIds (opcional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipantClubControllerFindAll(eventId?: string, sequential?: number, qrCode?: string, status?: Array<any>, name?: string, perPage?: any, page?: any, ticketsId?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsParticipantsClubResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipantClubControllerFindAll(eventId, sequential, qrCode, status, name, perPage, page, ticketsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get unique participation by user
         * @param {string} id Event User Participant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipantClubControllerFindOneParticipation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventParticipantClubDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipantClubControllerFindOneParticipation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit photo/avatar for a event participant
         * @param {string} id Event Participant ID
         * @param {File} photo Binary data of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipantClubControllerUploadPhoto(id: string, photo: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventParticipantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipantClubControllerUploadPhoto(id, photo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClubEventParticipantClubApi - factory interface
 * @export
 */
export const ClubEventParticipantClubApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClubEventParticipantClubApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an participant
         * @param {string} eventTicketGuestId Event Ticket Guest ID
         * @param {CreateEventParticipantClubDto} createEventParticipantClubDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantClubControllerCreate(eventTicketGuestId: string, createEventParticipantClubDto: CreateEventParticipantClubDto, options?: any): AxiosPromise<EventParticipantClubGuestResponse> {
            return localVarFp.eventParticipantClubControllerCreate(eventTicketGuestId, createEventParticipantClubDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all participation by user
         * @param {string} [eventId] Event ID
         * @param {number} [sequential] 
         * @param {string} [qrCode] 
         * @param {Array<any>} [status] Array de status (opcional)
         * @param {string} [name] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {Array<any>} [ticketsId] Array de ticketsIds (opcional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantClubControllerFindAll(eventId?: string, sequential?: number, qrCode?: string, status?: Array<any>, name?: string, perPage?: any, page?: any, ticketsId?: Array<any>, options?: any): AxiosPromise<EventsParticipantsClubResponse> {
            return localVarFp.eventParticipantClubControllerFindAll(eventId, sequential, qrCode, status, name, perPage, page, ticketsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get unique participation by user
         * @param {string} id Event User Participant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantClubControllerFindOneParticipation(id: string, options?: any): AxiosPromise<ResponseEventParticipantClubDto> {
            return localVarFp.eventParticipantClubControllerFindOneParticipation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit photo/avatar for a event participant
         * @param {string} id Event Participant ID
         * @param {File} photo Binary data of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantClubControllerUploadPhoto(id: string, photo: File, options?: any): AxiosPromise<EventParticipantResponse> {
            return localVarFp.eventParticipantClubControllerUploadPhoto(id, photo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClubEventParticipantClubApi - object-oriented interface
 * @export
 * @class ClubEventParticipantClubApi
 * @extends {BaseAPI}
 */
export class ClubEventParticipantClubApi extends BaseAPI {
    /**
     * 
     * @summary Create an participant
     * @param {string} eventTicketGuestId Event Ticket Guest ID
     * @param {CreateEventParticipantClubDto} createEventParticipantClubDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubEventParticipantClubApi
     */
    public eventParticipantClubControllerCreate(eventTicketGuestId: string, createEventParticipantClubDto: CreateEventParticipantClubDto, options?: AxiosRequestConfig) {
        return ClubEventParticipantClubApiFp(this.configuration).eventParticipantClubControllerCreate(eventTicketGuestId, createEventParticipantClubDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all participation by user
     * @param {string} [eventId] Event ID
     * @param {number} [sequential] 
     * @param {string} [qrCode] 
     * @param {Array<any>} [status] Array de status (opcional)
     * @param {string} [name] 
     * @param {any} [perPage] 
     * @param {any} [page] 
     * @param {Array<any>} [ticketsId] Array de ticketsIds (opcional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubEventParticipantClubApi
     */
    public eventParticipantClubControllerFindAll(eventId?: string, sequential?: number, qrCode?: string, status?: Array<any>, name?: string, perPage?: any, page?: any, ticketsId?: Array<any>, options?: AxiosRequestConfig) {
        return ClubEventParticipantClubApiFp(this.configuration).eventParticipantClubControllerFindAll(eventId, sequential, qrCode, status, name, perPage, page, ticketsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get unique participation by user
     * @param {string} id Event User Participant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubEventParticipantClubApi
     */
    public eventParticipantClubControllerFindOneParticipation(id: string, options?: AxiosRequestConfig) {
        return ClubEventParticipantClubApiFp(this.configuration).eventParticipantClubControllerFindOneParticipation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit photo/avatar for a event participant
     * @param {string} id Event Participant ID
     * @param {File} photo Binary data of the photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubEventParticipantClubApi
     */
    public eventParticipantClubControllerUploadPhoto(id: string, photo: File, options?: AxiosRequestConfig) {
        return ClubEventParticipantClubApiFp(this.configuration).eventParticipantClubControllerUploadPhoto(id, photo, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClubEventTicketGuestApi - axios parameter creator
 * @export
 */
export const ClubEventTicketGuestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find an event guest especific
         * @param {string} id Event Ticket Guest ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketGuestClubControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventTicketGuestClubControllerFindOne', 'id', id)
            const localVarPath = `/event/club/v1/event-ticket-guest/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClubEventTicketGuestApi - functional programming interface
 * @export
 */
export const ClubEventTicketGuestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClubEventTicketGuestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Find an event guest especific
         * @param {string} id Event Ticket Guest ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTicketGuestClubControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventTicketGuestClubDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTicketGuestClubControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClubEventTicketGuestApi - factory interface
 * @export
 */
export const ClubEventTicketGuestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClubEventTicketGuestApiFp(configuration)
    return {
        /**
         * 
         * @summary Find an event guest especific
         * @param {string} id Event Ticket Guest ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketGuestClubControllerFindOne(id: string, options?: any): AxiosPromise<ResponseEventTicketGuestClubDto> {
            return localVarFp.eventTicketGuestClubControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClubEventTicketGuestApi - object-oriented interface
 * @export
 * @class ClubEventTicketGuestApi
 * @extends {BaseAPI}
 */
export class ClubEventTicketGuestApi extends BaseAPI {
    /**
     * 
     * @summary Find an event guest especific
     * @param {string} id Event Ticket Guest ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubEventTicketGuestApi
     */
    public eventTicketGuestClubControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return ClubEventTicketGuestApiFp(this.configuration).eventTicketGuestClubControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentApi - axios parameter creator
 * @export
 */
export const DocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an document for user
         * @param {string} userId User Id
         * @param {CreateDocumentDto} createDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreate: async (userId: string, createDocumentDto: CreateDocumentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('documentControllerCreate', 'userId', userId)
            // verify required parameter 'createDocumentDto' is not null or undefined
            assertParamExists('documentControllerCreate', 'createDocumentDto', createDocumentDto)
            const localVarPath = `/document/v1/document/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDocumentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an document for user
         * @param {string} userId User Id
         * @param {CreateDocumentClubDTO} createDocumentClubDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreateClub: async (userId: string, createDocumentClubDTO: CreateDocumentClubDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('documentControllerCreateClub', 'userId', userId)
            // verify required parameter 'createDocumentClubDTO' is not null or undefined
            assertParamExists('documentControllerCreateClub', 'createDocumentClubDTO', createDocumentClubDTO)
            const localVarPath = `/document/v1/document/club/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDocumentClubDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get documents with filter
         * @param {string} filter 
         * @param {number} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerFindAll: async (filter: string, perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('documentControllerFindAll', 'filter', filter)
            const localVarPath = `/document/v1/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a document by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerFindOne', 'id', id)
            const localVarPath = `/document/v1/document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a document by ID
         * @param {string} id Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerRemove', 'id', id)
            const localVarPath = `/document/v1/document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a document by ID
         * @param {string} id Document ID
         * @param {UpdateDocumentDto} updateDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdate: async (id: string, updateDocumentDto: UpdateDocumentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerUpdate', 'id', id)
            // verify required parameter 'updateDocumentDto' is not null or undefined
            assertParamExists('documentControllerUpdate', 'updateDocumentDto', updateDocumentDto)
            const localVarPath = `/document/v1/document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDocumentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload photo document by ID
         * @param {string} id Document ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUploadPhoto: async (id: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerUploadPhoto', 'id', id)
            const localVarPath = `/document/v1/document/photo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload back photo a document by ID
         * @param {string} id Document ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUploadPhotoBack: async (id: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerUploadPhotoBack', 'id', id)
            const localVarPath = `/document/v1/document/photo-back/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an document for user
         * @param {string} userId User Id
         * @param {CreateDocumentDto} createDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerCreate(userId: string, createDocumentDto: CreateDocumentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDocumentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerCreate(userId, createDocumentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an document for user
         * @param {string} userId User Id
         * @param {CreateDocumentClubDTO} createDocumentClubDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerCreateClub(userId: string, createDocumentClubDTO: CreateDocumentClubDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDocumentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerCreateClub(userId, createDocumentClubDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get documents with filter
         * @param {string} filter 
         * @param {number} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerFindAll(filter: string, perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerFindAll(filter, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a document by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a document by ID
         * @param {string} id Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a document by ID
         * @param {string} id Document ID
         * @param {UpdateDocumentDto} updateDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUpdate(id: string, updateDocumentDto: UpdateDocumentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUpdate(id, updateDocumentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload photo document by ID
         * @param {string} id Document ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUploadPhoto(id: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUploadPhoto(id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload back photo a document by ID
         * @param {string} id Document ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUploadPhotoBack(id: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUploadPhotoBack(id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an document for user
         * @param {string} userId User Id
         * @param {CreateDocumentDto} createDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreate(userId: string, createDocumentDto: CreateDocumentDto, options?: any): AxiosPromise<ResponseDocumentDto> {
            return localVarFp.documentControllerCreate(userId, createDocumentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an document for user
         * @param {string} userId User Id
         * @param {CreateDocumentClubDTO} createDocumentClubDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreateClub(userId: string, createDocumentClubDTO: CreateDocumentClubDTO, options?: any): AxiosPromise<ResponseDocumentDto> {
            return localVarFp.documentControllerCreateClub(userId, createDocumentClubDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get documents with filter
         * @param {string} filter 
         * @param {number} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerFindAll(filter: string, perPage?: number, page?: number, options?: any): AxiosPromise<DocumentsResponse> {
            return localVarFp.documentControllerFindAll(filter, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a document by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerFindOne(id: string, options?: any): AxiosPromise<DocumentResponse> {
            return localVarFp.documentControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a document by ID
         * @param {string} id Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.documentControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a document by ID
         * @param {string} id Document ID
         * @param {UpdateDocumentDto} updateDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdate(id: string, updateDocumentDto: UpdateDocumentDto, options?: any): AxiosPromise<DocumentResponse> {
            return localVarFp.documentControllerUpdate(id, updateDocumentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload photo document by ID
         * @param {string} id Document ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUploadPhoto(id: string, file?: File, options?: any): AxiosPromise<DocumentResponse> {
            return localVarFp.documentControllerUploadPhoto(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload back photo a document by ID
         * @param {string} id Document ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUploadPhotoBack(id: string, file?: File, options?: any): AxiosPromise<DocumentResponse> {
            return localVarFp.documentControllerUploadPhotoBack(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * 
     * @summary Create an document for user
     * @param {string} userId User Id
     * @param {CreateDocumentDto} createDocumentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerCreate(userId: string, createDocumentDto: CreateDocumentDto, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerCreate(userId, createDocumentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an document for user
     * @param {string} userId User Id
     * @param {CreateDocumentClubDTO} createDocumentClubDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerCreateClub(userId: string, createDocumentClubDTO: CreateDocumentClubDTO, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerCreateClub(userId, createDocumentClubDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get documents with filter
     * @param {string} filter 
     * @param {number} [perPage] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerFindAll(filter: string, perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerFindAll(filter, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a document by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a document by ID
     * @param {string} id Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerRemove(id: string, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a document by ID
     * @param {string} id Document ID
     * @param {UpdateDocumentDto} updateDocumentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerUpdate(id: string, updateDocumentDto: UpdateDocumentDto, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerUpdate(id, updateDocumentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload photo document by ID
     * @param {string} id Document ID
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerUploadPhoto(id: string, file?: File, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerUploadPhoto(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload back photo a document by ID
     * @param {string} id Document ID
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerUploadPhotoBack(id: string, file?: File, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerUploadPhotoBack(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentAndTermApi - axios parameter creator
 * @export
 */
export const DocumentAndTermApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an document and terms
         * @param {string} name Nome do documento
         * @param {File} file Arquivo em formato binário
         * @param {string} deadlineAt Data de vencimento
         * @param {boolean} autoClose Indica se o documento deve ser fechado automaticamente
         * @param {string} locale Localidade do documento
         * @param {boolean} sequenceEnabled Habilitar sequência
         * @param {string} remindInterval Intervalo de lembrete
         * @param {boolean} blockAfterRefusal Bloquear após recusa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAndTermControllerCreate: async (name: string, file: File, deadlineAt: string, autoClose: boolean, locale: string, sequenceEnabled: boolean, remindInterval: string, blockAfterRefusal: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('documentAndTermControllerCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('documentAndTermControllerCreate', 'file', file)
            // verify required parameter 'deadlineAt' is not null or undefined
            assertParamExists('documentAndTermControllerCreate', 'deadlineAt', deadlineAt)
            // verify required parameter 'autoClose' is not null or undefined
            assertParamExists('documentAndTermControllerCreate', 'autoClose', autoClose)
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('documentAndTermControllerCreate', 'locale', locale)
            // verify required parameter 'sequenceEnabled' is not null or undefined
            assertParamExists('documentAndTermControllerCreate', 'sequenceEnabled', sequenceEnabled)
            // verify required parameter 'remindInterval' is not null or undefined
            assertParamExists('documentAndTermControllerCreate', 'remindInterval', remindInterval)
            // verify required parameter 'blockAfterRefusal' is not null or undefined
            assertParamExists('documentAndTermControllerCreate', 'blockAfterRefusal', blockAfterRefusal)
            const localVarPath = `/document-and-term/v1/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (deadlineAt !== undefined) { 
                localVarFormParams.append('deadlineAt', deadlineAt as any);
            }
    
            if (autoClose !== undefined) { 
                localVarFormParams.append('autoClose', autoClose as any);
            }
    
            if (locale !== undefined) { 
                localVarFormParams.append('locale', locale as any);
            }
    
            if (sequenceEnabled !== undefined) { 
                localVarFormParams.append('sequenceEnabled', sequenceEnabled as any);
            }
    
            if (remindInterval !== undefined) { 
                localVarFormParams.append('remindInterval', remindInterval as any);
            }
    
            if (blockAfterRefusal !== undefined) { 
                localVarFormParams.append('blockAfterRefusal', blockAfterRefusal as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get with filter an document and terms
         * @param {string} [id] ID do documento
         * @param {string} [startDate] Data de início do intervalo de datas
         * @param {string} [endDate] Data de término do intervalo de datas
         * @param {number} [page] Página
         * @param {string} [perPage] Itens por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAndTermControllerFindAll: async (id?: string, startDate?: string, endDate?: string, page?: number, perPage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/document-and-term/v1/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAndTermControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentAndTermControllerRemove', 'id', id)
            const localVarPath = `/document-and-term/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateDocumentAndTermDto} updateDocumentAndTermDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAndTermControllerUpdate: async (id: string, updateDocumentAndTermDto: UpdateDocumentAndTermDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentAndTermControllerUpdate', 'id', id)
            // verify required parameter 'updateDocumentAndTermDto' is not null or undefined
            assertParamExists('documentAndTermControllerUpdate', 'updateDocumentAndTermDto', updateDocumentAndTermDto)
            const localVarPath = `/document-and-term/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDocumentAndTermDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentAndTermApi - functional programming interface
 * @export
 */
export const DocumentAndTermApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentAndTermApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an document and terms
         * @param {string} name Nome do documento
         * @param {File} file Arquivo em formato binário
         * @param {string} deadlineAt Data de vencimento
         * @param {boolean} autoClose Indica se o documento deve ser fechado automaticamente
         * @param {string} locale Localidade do documento
         * @param {boolean} sequenceEnabled Habilitar sequência
         * @param {string} remindInterval Intervalo de lembrete
         * @param {boolean} blockAfterRefusal Bloquear após recusa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentAndTermControllerCreate(name: string, file: File, deadlineAt: string, autoClose: boolean, locale: string, sequenceEnabled: boolean, remindInterval: string, blockAfterRefusal: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDocumentAndTermDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentAndTermControllerCreate(name, file, deadlineAt, autoClose, locale, sequenceEnabled, remindInterval, blockAfterRefusal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get with filter an document and terms
         * @param {string} [id] ID do documento
         * @param {string} [startDate] Data de início do intervalo de datas
         * @param {string} [endDate] Data de término do intervalo de datas
         * @param {number} [page] Página
         * @param {string} [perPage] Itens por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentAndTermControllerFindAll(id?: string, startDate?: string, endDate?: string, page?: number, perPage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentAndTermControllerFindAll(id, startDate, endDate, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentAndTermControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentAndTermControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateDocumentAndTermDto} updateDocumentAndTermDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentAndTermControllerUpdate(id: string, updateDocumentAndTermDto: UpdateDocumentAndTermDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentAndTermControllerUpdate(id, updateDocumentAndTermDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentAndTermApi - factory interface
 * @export
 */
export const DocumentAndTermApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentAndTermApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an document and terms
         * @param {string} name Nome do documento
         * @param {File} file Arquivo em formato binário
         * @param {string} deadlineAt Data de vencimento
         * @param {boolean} autoClose Indica se o documento deve ser fechado automaticamente
         * @param {string} locale Localidade do documento
         * @param {boolean} sequenceEnabled Habilitar sequência
         * @param {string} remindInterval Intervalo de lembrete
         * @param {boolean} blockAfterRefusal Bloquear após recusa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAndTermControllerCreate(name: string, file: File, deadlineAt: string, autoClose: boolean, locale: string, sequenceEnabled: boolean, remindInterval: string, blockAfterRefusal: boolean, options?: any): AxiosPromise<ResponseDocumentAndTermDto> {
            return localVarFp.documentAndTermControllerCreate(name, file, deadlineAt, autoClose, locale, sequenceEnabled, remindInterval, blockAfterRefusal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get with filter an document and terms
         * @param {string} [id] ID do documento
         * @param {string} [startDate] Data de início do intervalo de datas
         * @param {string} [endDate] Data de término do intervalo de datas
         * @param {number} [page] Página
         * @param {string} [perPage] Itens por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAndTermControllerFindAll(id?: string, startDate?: string, endDate?: string, page?: number, perPage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.documentAndTermControllerFindAll(id, startDate, endDate, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAndTermControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.documentAndTermControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateDocumentAndTermDto} updateDocumentAndTermDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAndTermControllerUpdate(id: string, updateDocumentAndTermDto: UpdateDocumentAndTermDto, options?: any): AxiosPromise<void> {
            return localVarFp.documentAndTermControllerUpdate(id, updateDocumentAndTermDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentAndTermApi - object-oriented interface
 * @export
 * @class DocumentAndTermApi
 * @extends {BaseAPI}
 */
export class DocumentAndTermApi extends BaseAPI {
    /**
     * 
     * @summary Create an document and terms
     * @param {string} name Nome do documento
     * @param {File} file Arquivo em formato binário
     * @param {string} deadlineAt Data de vencimento
     * @param {boolean} autoClose Indica se o documento deve ser fechado automaticamente
     * @param {string} locale Localidade do documento
     * @param {boolean} sequenceEnabled Habilitar sequência
     * @param {string} remindInterval Intervalo de lembrete
     * @param {boolean} blockAfterRefusal Bloquear após recusa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAndTermApi
     */
    public documentAndTermControllerCreate(name: string, file: File, deadlineAt: string, autoClose: boolean, locale: string, sequenceEnabled: boolean, remindInterval: string, blockAfterRefusal: boolean, options?: AxiosRequestConfig) {
        return DocumentAndTermApiFp(this.configuration).documentAndTermControllerCreate(name, file, deadlineAt, autoClose, locale, sequenceEnabled, remindInterval, blockAfterRefusal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get with filter an document and terms
     * @param {string} [id] ID do documento
     * @param {string} [startDate] Data de início do intervalo de datas
     * @param {string} [endDate] Data de término do intervalo de datas
     * @param {number} [page] Página
     * @param {string} [perPage] Itens por página
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAndTermApi
     */
    public documentAndTermControllerFindAll(id?: string, startDate?: string, endDate?: string, page?: number, perPage?: string, options?: AxiosRequestConfig) {
        return DocumentAndTermApiFp(this.configuration).documentAndTermControllerFindAll(id, startDate, endDate, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAndTermApi
     */
    public documentAndTermControllerRemove(id: string, options?: AxiosRequestConfig) {
        return DocumentAndTermApiFp(this.configuration).documentAndTermControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateDocumentAndTermDto} updateDocumentAndTermDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAndTermApi
     */
    public documentAndTermControllerUpdate(id: string, updateDocumentAndTermDto: UpdateDocumentAndTermDto, options?: AxiosRequestConfig) {
        return DocumentAndTermApiFp(this.configuration).documentAndTermControllerUpdate(id, updateDocumentAndTermDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an event for account
         * @param {CreateEventDto} createEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerCreate: async (createEventDto: CreateEventDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventDto' is not null or undefined
            assertParamExists('eventControllerCreate', 'createEventDto', createEventDto)
            const localVarPath = `/event/v1/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an events with filter
         * @param {string} [userId] 
         * @param {EventControllerFindAllStatusEnum} [status] 
         * @param {string} [name] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerFindAll: async (userId?: string, status?: EventControllerFindAllStatusEnum, name?: string, perPage?: any, page?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event/v1/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all active events
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerFindAllEnableEvents: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventControllerFindAllEnableEvents', 'id', id)
            const localVarPath = `/event/v1/event/get-all-active-events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an event especific
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventControllerFindOne', 'id', id)
            const localVarPath = `/event/v1/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post photo by event
         * @param {string} id Event ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerInsertPhoto: async (id: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventControllerInsertPhoto', 'id', id)
            const localVarPath = `/event/v1/event/{id}/photo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event by ID
         * @param {string} id ID of the event to be updated
         * @param {UpdateEventDto} updateEventDto Data for updating the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerUpdate: async (id: string, updateEventDto: UpdateEventDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventControllerUpdate', 'id', id)
            // verify required parameter 'updateEventDto' is not null or undefined
            assertParamExists('eventControllerUpdate', 'updateEventDto', updateEventDto)
            const localVarPath = `/event/v1/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an event for account
         * @param {CreateEventDto} createEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventControllerCreate(createEventDto: CreateEventDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerCreate(createEventDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an events with filter
         * @param {string} [userId] 
         * @param {EventControllerFindAllStatusEnum} [status] 
         * @param {string} [name] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventControllerFindAll(userId?: string, status?: EventControllerFindAllStatusEnum, name?: string, perPage?: any, page?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerFindAll(userId, status, name, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all active events
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventControllerFindAllEnableEvents(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerFindAllEnableEvents(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an event especific
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post photo by event
         * @param {string} id Event ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventControllerInsertPhoto(id: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerInsertPhoto(id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an event by ID
         * @param {string} id ID of the event to be updated
         * @param {UpdateEventDto} updateEventDto Data for updating the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventControllerUpdate(id: string, updateEventDto: UpdateEventDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerUpdate(id, updateEventDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an event for account
         * @param {CreateEventDto} createEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerCreate(createEventDto: CreateEventDto, options?: any): AxiosPromise<ResponseEventDto> {
            return localVarFp.eventControllerCreate(createEventDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an events with filter
         * @param {string} [userId] 
         * @param {EventControllerFindAllStatusEnum} [status] 
         * @param {string} [name] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerFindAll(userId?: string, status?: EventControllerFindAllStatusEnum, name?: string, perPage?: any, page?: any, options?: any): AxiosPromise<EventsResponse> {
            return localVarFp.eventControllerFindAll(userId, status, name, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all active events
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerFindAllEnableEvents(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.eventControllerFindAllEnableEvents(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an event especific
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerFindOne(id: string, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.eventControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post photo by event
         * @param {string} id Event ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerInsertPhoto(id: string, file?: File, options?: any): AxiosPromise<ResponseEventDto> {
            return localVarFp.eventControllerInsertPhoto(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event by ID
         * @param {string} id ID of the event to be updated
         * @param {UpdateEventDto} updateEventDto Data for updating the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerUpdate(id: string, updateEventDto: UpdateEventDto, options?: any): AxiosPromise<ResponseEventDto> {
            return localVarFp.eventControllerUpdate(id, updateEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary Create an event for account
     * @param {CreateEventDto} createEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventControllerCreate(createEventDto: CreateEventDto, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).eventControllerCreate(createEventDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an events with filter
     * @param {string} [userId] 
     * @param {EventControllerFindAllStatusEnum} [status] 
     * @param {string} [name] 
     * @param {any} [perPage] 
     * @param {any} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventControllerFindAll(userId?: string, status?: EventControllerFindAllStatusEnum, name?: string, perPage?: any, page?: any, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).eventControllerFindAll(userId, status, name, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all active events
     * @param {string} id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventControllerFindAllEnableEvents(id: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).eventControllerFindAllEnableEvents(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an event especific
     * @param {string} id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).eventControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post photo by event
     * @param {string} id Event ID
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventControllerInsertPhoto(id: string, file?: File, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).eventControllerInsertPhoto(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event by ID
     * @param {string} id ID of the event to be updated
     * @param {UpdateEventDto} updateEventDto Data for updating the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventControllerUpdate(id: string, updateEventDto: UpdateEventDto, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).eventControllerUpdate(id, updateEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EventControllerFindAllStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;
export type EventControllerFindAllStatusEnum = typeof EventControllerFindAllStatusEnum[keyof typeof EventControllerFindAllStatusEnum];


/**
 * EventConfigApi - axios parameter creator
 * @export
 */
export const EventConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a event configuration
         * @param {string} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventConfigControllerFind: async (eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventConfigControllerFind', 'eventId', eventId)
            const localVarPath = `/event/v1/event-config/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} eventId Event ID
         * @param {string} id Event Config ID
         * @param {UpdateEventConfigDto} updateEventConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventConfigControllerUpdate: async (eventId: string, id: string, updateEventConfigDto: UpdateEventConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventConfigControllerUpdate', 'eventId', eventId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventConfigControllerUpdate', 'id', id)
            // verify required parameter 'updateEventConfigDto' is not null or undefined
            assertParamExists('eventConfigControllerUpdate', 'updateEventConfigDto', updateEventConfigDto)
            const localVarPath = `/event/v1/event-config/{eventId}/{id}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventConfigApi - functional programming interface
 * @export
 */
export const EventConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a event configuration
         * @param {string} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventConfigControllerFind(eventId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventConfigControllerFind(eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} eventId Event ID
         * @param {string} id Event Config ID
         * @param {UpdateEventConfigDto} updateEventConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventConfigControllerUpdate(eventId: string, id: string, updateEventConfigDto: UpdateEventConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventConfigControllerUpdate(eventId, id, updateEventConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventConfigApi - factory interface
 * @export
 */
export const EventConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventConfigApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a event configuration
         * @param {string} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventConfigControllerFind(eventId: string, options?: any): AxiosPromise<EventConfigResponse> {
            return localVarFp.eventConfigControllerFind(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} eventId Event ID
         * @param {string} id Event Config ID
         * @param {UpdateEventConfigDto} updateEventConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventConfigControllerUpdate(eventId: string, id: string, updateEventConfigDto: UpdateEventConfigDto, options?: any): AxiosPromise<EventConfigResponse> {
            return localVarFp.eventConfigControllerUpdate(eventId, id, updateEventConfigDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventConfigApi - object-oriented interface
 * @export
 * @class EventConfigApi
 * @extends {BaseAPI}
 */
export class EventConfigApi extends BaseAPI {
    /**
     * 
     * @summary Get a event configuration
     * @param {string} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventConfigApi
     */
    public eventConfigControllerFind(eventId: string, options?: AxiosRequestConfig) {
        return EventConfigApiFp(this.configuration).eventConfigControllerFind(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an participant especific
     * @param {string} eventId Event ID
     * @param {string} id Event Config ID
     * @param {UpdateEventConfigDto} updateEventConfigDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventConfigApi
     */
    public eventConfigControllerUpdate(eventId: string, id: string, updateEventConfigDto: UpdateEventConfigDto, options?: AxiosRequestConfig) {
        return EventConfigApiFp(this.configuration).eventConfigControllerUpdate(eventId, id, updateEventConfigDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventParticipantApi - axios parameter creator
 * @export
 */
export const EventParticipantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an participant
         * @param {string} eventTicketGuestId Event Ticket Guest ID
         * @param {CreateEventParticipantDto} createEventParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerCreate: async (eventTicketGuestId: string, createEventParticipantDto: CreateEventParticipantDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventTicketGuestId' is not null or undefined
            assertParamExists('eventParticipanteControllerCreate', 'eventTicketGuestId', eventTicketGuestId)
            // verify required parameter 'createEventParticipantDto' is not null or undefined
            assertParamExists('eventParticipanteControllerCreate', 'createEventParticipantDto', createEventParticipantDto)
            const localVarPath = `/event/v1/event-participant/{eventTicketGuestId}`
                .replace(`{${"eventTicketGuestId"}}`, encodeURIComponent(String(eventTicketGuestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventParticipantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {Array<any>} eventIds Array de eventIds
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerFindAllParticipants: async (eventIds: Array<any>, perPage?: any, page?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventIds' is not null or undefined
            assertParamExists('eventParticipanteControllerFindAllParticipants', 'eventIds', eventIds)
            const localVarPath = `/event/v1/event-participant/invicta-client/find-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventIds) {
                localVarQueryParameter['eventIds'] = eventIds;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} eventId Event ID
         * @param {string} id Participant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerFindOne: async (eventId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventParticipanteControllerFindOne', 'eventId', eventId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventParticipanteControllerFindOne', 'id', id)
            const localVarPath = `/event/v1/event-participant/{eventId}/{id}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} id Participant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerFindParticipant: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventParticipanteControllerFindParticipant', 'id', id)
            const localVarPath = `/event/v1/event-participant/invicta-client/find-unique/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} eventId Event ID
         * @param {string} id Participant ID
         * @param {UpdateEventParticipantDto} updateEventParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerUpdate: async (eventId: string, id: string, updateEventParticipantDto: UpdateEventParticipantDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventParticipanteControllerUpdate', 'eventId', eventId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventParticipanteControllerUpdate', 'id', id)
            // verify required parameter 'updateEventParticipantDto' is not null or undefined
            assertParamExists('eventParticipanteControllerUpdate', 'updateEventParticipantDto', updateEventParticipantDto)
            const localVarPath = `/event/v1/event-participant/{eventId}/{id}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventParticipantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Print is update to true
         * @param {Array<any>} ids Array de ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerUpdateIsSynchronized: async (ids: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('eventParticipanteControllerUpdateIsSynchronized', 'ids', ids)
            const localVarPath = `/event/v1/event-participant/is-synchronized`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit photo/avatar for a event participant
         * @param {string} id Event Participant ID
         * @param {File} photo Binary data of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerUploadPhoto: async (id: string, photo: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventParticipanteControllerUploadPhoto', 'id', id)
            // verify required parameter 'photo' is not null or undefined
            assertParamExists('eventParticipanteControllerUploadPhoto', 'photo', photo)
            const localVarPath = `/event/v1/event-participant/{id}/photo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (photo !== undefined) { 
                localVarFormParams.append('photo', photo as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventParticipantApi - functional programming interface
 * @export
 */
export const EventParticipantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventParticipantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an participant
         * @param {string} eventTicketGuestId Event Ticket Guest ID
         * @param {CreateEventParticipantDto} createEventParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipanteControllerCreate(eventTicketGuestId: string, createEventParticipantDto: CreateEventParticipantDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventParticipantClubGuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipanteControllerCreate(eventTicketGuestId, createEventParticipantDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {Array<any>} eventIds Array de eventIds
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipanteControllerFindAllParticipants(eventIds: Array<any>, perPage?: any, page?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseAllEventParticipantsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipanteControllerFindAllParticipants(eventIds, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} eventId Event ID
         * @param {string} id Participant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipanteControllerFindOne(eventId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventParticipantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipanteControllerFindOne(eventId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} id Participant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipanteControllerFindParticipant(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventParticipantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipanteControllerFindParticipant(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} eventId Event ID
         * @param {string} id Participant ID
         * @param {UpdateEventParticipantDto} updateEventParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipanteControllerUpdate(eventId: string, id: string, updateEventParticipantDto: UpdateEventParticipantDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventParticipantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipanteControllerUpdate(eventId, id, updateEventParticipantDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Print is update to true
         * @param {Array<any>} ids Array de ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipanteControllerUpdateIsSynchronized(ids: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventParticipantResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipanteControllerUpdateIsSynchronized(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit photo/avatar for a event participant
         * @param {string} id Event Participant ID
         * @param {File} photo Binary data of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipanteControllerUploadPhoto(id: string, photo: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventParticipantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipanteControllerUploadPhoto(id, photo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventParticipantApi - factory interface
 * @export
 */
export const EventParticipantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventParticipantApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an participant
         * @param {string} eventTicketGuestId Event Ticket Guest ID
         * @param {CreateEventParticipantDto} createEventParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerCreate(eventTicketGuestId: string, createEventParticipantDto: CreateEventParticipantDto, options?: any): AxiosPromise<EventParticipantClubGuestResponse> {
            return localVarFp.eventParticipanteControllerCreate(eventTicketGuestId, createEventParticipantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {Array<any>} eventIds Array de eventIds
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerFindAllParticipants(eventIds: Array<any>, perPage?: any, page?: any, options?: any): AxiosPromise<Array<ResponseAllEventParticipantsDto>> {
            return localVarFp.eventParticipanteControllerFindAllParticipants(eventIds, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} eventId Event ID
         * @param {string} id Participant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerFindOne(eventId: string, id: string, options?: any): AxiosPromise<EventParticipantResponse> {
            return localVarFp.eventParticipanteControllerFindOne(eventId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} id Participant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerFindParticipant(id: string, options?: any): AxiosPromise<EventParticipantResponse> {
            return localVarFp.eventParticipanteControllerFindParticipant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an participant especific
         * @param {string} eventId Event ID
         * @param {string} id Participant ID
         * @param {UpdateEventParticipantDto} updateEventParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerUpdate(eventId: string, id: string, updateEventParticipantDto: UpdateEventParticipantDto, options?: any): AxiosPromise<EventParticipantResponse> {
            return localVarFp.eventParticipanteControllerUpdate(eventId, id, updateEventParticipantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Print is update to true
         * @param {Array<any>} ids Array de ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerUpdateIsSynchronized(ids: Array<any>, options?: any): AxiosPromise<Array<EventParticipantResponse>> {
            return localVarFp.eventParticipanteControllerUpdateIsSynchronized(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit photo/avatar for a event participant
         * @param {string} id Event Participant ID
         * @param {File} photo Binary data of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipanteControllerUploadPhoto(id: string, photo: File, options?: any): AxiosPromise<EventParticipantResponse> {
            return localVarFp.eventParticipanteControllerUploadPhoto(id, photo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventParticipantApi - object-oriented interface
 * @export
 * @class EventParticipantApi
 * @extends {BaseAPI}
 */
export class EventParticipantApi extends BaseAPI {
    /**
     * 
     * @summary Create an participant
     * @param {string} eventTicketGuestId Event Ticket Guest ID
     * @param {CreateEventParticipantDto} createEventParticipantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantApi
     */
    public eventParticipanteControllerCreate(eventTicketGuestId: string, createEventParticipantDto: CreateEventParticipantDto, options?: AxiosRequestConfig) {
        return EventParticipantApiFp(this.configuration).eventParticipanteControllerCreate(eventTicketGuestId, createEventParticipantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an participant especific
     * @param {Array<any>} eventIds Array de eventIds
     * @param {any} [perPage] 
     * @param {any} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantApi
     */
    public eventParticipanteControllerFindAllParticipants(eventIds: Array<any>, perPage?: any, page?: any, options?: AxiosRequestConfig) {
        return EventParticipantApiFp(this.configuration).eventParticipanteControllerFindAllParticipants(eventIds, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an participant especific
     * @param {string} eventId Event ID
     * @param {string} id Participant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantApi
     */
    public eventParticipanteControllerFindOne(eventId: string, id: string, options?: AxiosRequestConfig) {
        return EventParticipantApiFp(this.configuration).eventParticipanteControllerFindOne(eventId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an participant especific
     * @param {string} id Participant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantApi
     */
    public eventParticipanteControllerFindParticipant(id: string, options?: AxiosRequestConfig) {
        return EventParticipantApiFp(this.configuration).eventParticipanteControllerFindParticipant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an participant especific
     * @param {string} eventId Event ID
     * @param {string} id Participant ID
     * @param {UpdateEventParticipantDto} updateEventParticipantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantApi
     */
    public eventParticipanteControllerUpdate(eventId: string, id: string, updateEventParticipantDto: UpdateEventParticipantDto, options?: AxiosRequestConfig) {
        return EventParticipantApiFp(this.configuration).eventParticipanteControllerUpdate(eventId, id, updateEventParticipantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Print is update to true
     * @param {Array<any>} ids Array de ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantApi
     */
    public eventParticipanteControllerUpdateIsSynchronized(ids: Array<any>, options?: AxiosRequestConfig) {
        return EventParticipantApiFp(this.configuration).eventParticipanteControllerUpdateIsSynchronized(ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit photo/avatar for a event participant
     * @param {string} id Event Participant ID
     * @param {File} photo Binary data of the photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantApi
     */
    public eventParticipanteControllerUploadPhoto(id: string, photo: File, options?: AxiosRequestConfig) {
        return EventParticipantApiFp(this.configuration).eventParticipanteControllerUploadPhoto(id, photo, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventParticipantStatusApi - axios parameter creator
 * @export
 */
export const EventParticipantStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an event participant status
         * @param {CreateEventParticipantStatusDto} createEventParticipantStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantStatusControllerCreate: async (createEventParticipantStatusDto: CreateEventParticipantStatusDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventParticipantStatusDto' is not null or undefined
            assertParamExists('eventParticipantStatusControllerCreate', 'createEventParticipantStatusDto', createEventParticipantStatusDto)
            const localVarPath = `/event/v1/event-participant-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventParticipantStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all event participant status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantStatusControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event/v1/event-participant-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find one event participant status
         * @param {string} id Event participant status id
         * @param {string} eventParticipantId Event participant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantStatusControllerFindOne: async (id: string, eventParticipantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventParticipantStatusControllerFindOne', 'id', id)
            // verify required parameter 'eventParticipantId' is not null or undefined
            assertParamExists('eventParticipantStatusControllerFindOne', 'eventParticipantId', eventParticipantId)
            const localVarPath = `/event/v1/event-participant-status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"eventParticipantId"}}`, encodeURIComponent(String(eventParticipantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event participant status
         * @param {string} id Event participant status id
         * @param {string} eventParticipantId Event participant id
         * @param {UpdateEventParticipantStatusDto} updateEventParticipantStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantStatusControllerUpdate: async (id: string, eventParticipantId: string, updateEventParticipantStatusDto: UpdateEventParticipantStatusDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventParticipantStatusControllerUpdate', 'id', id)
            // verify required parameter 'eventParticipantId' is not null or undefined
            assertParamExists('eventParticipantStatusControllerUpdate', 'eventParticipantId', eventParticipantId)
            // verify required parameter 'updateEventParticipantStatusDto' is not null or undefined
            assertParamExists('eventParticipantStatusControllerUpdate', 'updateEventParticipantStatusDto', updateEventParticipantStatusDto)
            const localVarPath = `/event/v1/event-participant-status/{id}/{eventParticipantId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"eventParticipantId"}}`, encodeURIComponent(String(eventParticipantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventParticipantStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventParticipantStatusApi - functional programming interface
 * @export
 */
export const EventParticipantStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventParticipantStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an event participant status
         * @param {CreateEventParticipantStatusDto} createEventParticipantStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipantStatusControllerCreate(createEventParticipantStatusDto: CreateEventParticipantStatusDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEventParticipantStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipantStatusControllerCreate(createEventParticipantStatusDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find all event participant status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipantStatusControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseEventParticipantStatusDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipantStatusControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find one event participant status
         * @param {string} id Event participant status id
         * @param {string} eventParticipantId Event participant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipantStatusControllerFindOne(id: string, eventParticipantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventParticipantStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipantStatusControllerFindOne(id, eventParticipantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an event participant status
         * @param {string} id Event participant status id
         * @param {string} eventParticipantId Event participant id
         * @param {UpdateEventParticipantStatusDto} updateEventParticipantStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventParticipantStatusControllerUpdate(id: string, eventParticipantId: string, updateEventParticipantStatusDto: UpdateEventParticipantStatusDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateEventParticipantStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventParticipantStatusControllerUpdate(id, eventParticipantId, updateEventParticipantStatusDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventParticipantStatusApi - factory interface
 * @export
 */
export const EventParticipantStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventParticipantStatusApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an event participant status
         * @param {CreateEventParticipantStatusDto} createEventParticipantStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantStatusControllerCreate(createEventParticipantStatusDto: CreateEventParticipantStatusDto, options?: any): AxiosPromise<CreateEventParticipantStatusDto> {
            return localVarFp.eventParticipantStatusControllerCreate(createEventParticipantStatusDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find all event participant status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantStatusControllerFindAll(options?: any): AxiosPromise<Array<ResponseEventParticipantStatusDto>> {
            return localVarFp.eventParticipantStatusControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find one event participant status
         * @param {string} id Event participant status id
         * @param {string} eventParticipantId Event participant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantStatusControllerFindOne(id: string, eventParticipantId: string, options?: any): AxiosPromise<ResponseEventParticipantStatusDto> {
            return localVarFp.eventParticipantStatusControllerFindOne(id, eventParticipantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event participant status
         * @param {string} id Event participant status id
         * @param {string} eventParticipantId Event participant id
         * @param {UpdateEventParticipantStatusDto} updateEventParticipantStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventParticipantStatusControllerUpdate(id: string, eventParticipantId: string, updateEventParticipantStatusDto: UpdateEventParticipantStatusDto, options?: any): AxiosPromise<UpdateEventParticipantStatusDto> {
            return localVarFp.eventParticipantStatusControllerUpdate(id, eventParticipantId, updateEventParticipantStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventParticipantStatusApi - object-oriented interface
 * @export
 * @class EventParticipantStatusApi
 * @extends {BaseAPI}
 */
export class EventParticipantStatusApi extends BaseAPI {
    /**
     * 
     * @summary Create an event participant status
     * @param {CreateEventParticipantStatusDto} createEventParticipantStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantStatusApi
     */
    public eventParticipantStatusControllerCreate(createEventParticipantStatusDto: CreateEventParticipantStatusDto, options?: AxiosRequestConfig) {
        return EventParticipantStatusApiFp(this.configuration).eventParticipantStatusControllerCreate(createEventParticipantStatusDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find all event participant status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantStatusApi
     */
    public eventParticipantStatusControllerFindAll(options?: AxiosRequestConfig) {
        return EventParticipantStatusApiFp(this.configuration).eventParticipantStatusControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find one event participant status
     * @param {string} id Event participant status id
     * @param {string} eventParticipantId Event participant id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantStatusApi
     */
    public eventParticipantStatusControllerFindOne(id: string, eventParticipantId: string, options?: AxiosRequestConfig) {
        return EventParticipantStatusApiFp(this.configuration).eventParticipantStatusControllerFindOne(id, eventParticipantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event participant status
     * @param {string} id Event participant status id
     * @param {string} eventParticipantId Event participant id
     * @param {UpdateEventParticipantStatusDto} updateEventParticipantStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantStatusApi
     */
    public eventParticipantStatusControllerUpdate(id: string, eventParticipantId: string, updateEventParticipantStatusDto: UpdateEventParticipantStatusDto, options?: AxiosRequestConfig) {
        return EventParticipantStatusApiFp(this.configuration).eventParticipantStatusControllerUpdate(id, eventParticipantId, updateEventParticipantStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventTicketApi - axios parameter creator
 * @export
 */
export const EventTicketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an ticket
         * @param {CreateEventTicketDto} createEventTicketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketControllerCreate: async (createEventTicketDto: CreateEventTicketDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventTicketDto' is not null or undefined
            assertParamExists('eventTicketControllerCreate', 'createEventTicketDto', createEventTicketDto)
            const localVarPath = `/event/v1/event-ticket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventTicketDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an tickets with filter
         * @param {string} [eventId] 
         * @param {EventTicketControllerFindAllStatusEnum} [status] 
         * @param {number} [guest] 
         * @param {string} [name] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketControllerFindAll: async (eventId?: string, status?: EventTicketControllerFindAllStatusEnum, guest?: number, name?: string, perPage?: any, page?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event/v1/event-ticket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (guest !== undefined) {
                localVarQueryParameter['guest'] = guest;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an event especific
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventTicketControllerFindOne', 'id', id)
            const localVarPath = `/event/v1/event-ticket/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event by ID
         * @param {string} id ID of the ticket to be updated
         * @param {UpdateEventTicketDto} updateEventTicketDto Data for updating the ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketControllerUpdate: async (id: string, updateEventTicketDto: UpdateEventTicketDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventTicketControllerUpdate', 'id', id)
            // verify required parameter 'updateEventTicketDto' is not null or undefined
            assertParamExists('eventTicketControllerUpdate', 'updateEventTicketDto', updateEventTicketDto)
            const localVarPath = `/event/v1/event-ticket/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventTicketDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventTicketApi - functional programming interface
 * @export
 */
export const EventTicketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventTicketApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an ticket
         * @param {CreateEventTicketDto} createEventTicketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTicketControllerCreate(createEventTicketDto: CreateEventTicketDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventTicketDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTicketControllerCreate(createEventTicketDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an tickets with filter
         * @param {string} [eventId] 
         * @param {EventTicketControllerFindAllStatusEnum} [status] 
         * @param {number} [guest] 
         * @param {string} [name] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTicketControllerFindAll(eventId?: string, status?: EventTicketControllerFindAllStatusEnum, guest?: number, name?: string, perPage?: any, page?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsTicketsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTicketControllerFindAll(eventId, status, guest, name, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an event especific
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTicketControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTicketControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an event by ID
         * @param {string} id ID of the ticket to be updated
         * @param {UpdateEventTicketDto} updateEventTicketDto Data for updating the ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTicketControllerUpdate(id: string, updateEventTicketDto: UpdateEventTicketDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventTicketDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTicketControllerUpdate(id, updateEventTicketDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventTicketApi - factory interface
 * @export
 */
export const EventTicketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventTicketApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an ticket
         * @param {CreateEventTicketDto} createEventTicketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketControllerCreate(createEventTicketDto: CreateEventTicketDto, options?: any): AxiosPromise<ResponseEventTicketDto> {
            return localVarFp.eventTicketControllerCreate(createEventTicketDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an tickets with filter
         * @param {string} [eventId] 
         * @param {EventTicketControllerFindAllStatusEnum} [status] 
         * @param {number} [guest] 
         * @param {string} [name] 
         * @param {any} [perPage] 
         * @param {any} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketControllerFindAll(eventId?: string, status?: EventTicketControllerFindAllStatusEnum, guest?: number, name?: string, perPage?: any, page?: any, options?: any): AxiosPromise<EventsTicketsResponse> {
            return localVarFp.eventTicketControllerFindAll(eventId, status, guest, name, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an event especific
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketControllerFindOne(id: string, options?: any): AxiosPromise<EventTicketResponse> {
            return localVarFp.eventTicketControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event by ID
         * @param {string} id ID of the ticket to be updated
         * @param {UpdateEventTicketDto} updateEventTicketDto Data for updating the ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketControllerUpdate(id: string, updateEventTicketDto: UpdateEventTicketDto, options?: any): AxiosPromise<ResponseEventTicketDto> {
            return localVarFp.eventTicketControllerUpdate(id, updateEventTicketDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventTicketApi - object-oriented interface
 * @export
 * @class EventTicketApi
 * @extends {BaseAPI}
 */
export class EventTicketApi extends BaseAPI {
    /**
     * 
     * @summary Create an ticket
     * @param {CreateEventTicketDto} createEventTicketDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTicketApi
     */
    public eventTicketControllerCreate(createEventTicketDto: CreateEventTicketDto, options?: AxiosRequestConfig) {
        return EventTicketApiFp(this.configuration).eventTicketControllerCreate(createEventTicketDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an tickets with filter
     * @param {string} [eventId] 
     * @param {EventTicketControllerFindAllStatusEnum} [status] 
     * @param {number} [guest] 
     * @param {string} [name] 
     * @param {any} [perPage] 
     * @param {any} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTicketApi
     */
    public eventTicketControllerFindAll(eventId?: string, status?: EventTicketControllerFindAllStatusEnum, guest?: number, name?: string, perPage?: any, page?: any, options?: AxiosRequestConfig) {
        return EventTicketApiFp(this.configuration).eventTicketControllerFindAll(eventId, status, guest, name, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an event especific
     * @param {string} id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTicketApi
     */
    public eventTicketControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return EventTicketApiFp(this.configuration).eventTicketControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event by ID
     * @param {string} id ID of the ticket to be updated
     * @param {UpdateEventTicketDto} updateEventTicketDto Data for updating the ticket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTicketApi
     */
    public eventTicketControllerUpdate(id: string, updateEventTicketDto: UpdateEventTicketDto, options?: AxiosRequestConfig) {
        return EventTicketApiFp(this.configuration).eventTicketControllerUpdate(id, updateEventTicketDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EventTicketControllerFindAllStatusEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;
export type EventTicketControllerFindAllStatusEnum = typeof EventTicketControllerFindAllStatusEnum[keyof typeof EventTicketControllerFindAllStatusEnum];


/**
 * EventTicketGuestApi - axios parameter creator
 * @export
 */
export const EventTicketGuestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create event ticket links
         * @param {string} eventId Event ID
         * @param {string} eventTicketId Event Ticket ID
         * @param {CreateEventTicketGuestDto} createEventTicketGuestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketGuestControllerCreate: async (eventId: string, eventTicketId: string, createEventTicketGuestDto: CreateEventTicketGuestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventTicketGuestControllerCreate', 'eventId', eventId)
            // verify required parameter 'eventTicketId' is not null or undefined
            assertParamExists('eventTicketGuestControllerCreate', 'eventTicketId', eventTicketId)
            // verify required parameter 'createEventTicketGuestDto' is not null or undefined
            assertParamExists('eventTicketGuestControllerCreate', 'createEventTicketGuestDto', createEventTicketGuestDto)
            const localVarPath = `/event/v1/event-ticket-guest/{eventId}/{eventTicketId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"eventTicketId"}}`, encodeURIComponent(String(eventTicketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventTicketGuestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export an tickets
         * @param {string} eventId Event ID
         * @param {Array<string>} [eventTicketStatus] Event ticket status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketGuestControllerExportFile: async (eventId: string, eventTicketStatus?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventTicketGuestControllerExportFile', 'eventId', eventId)
            const localVarPath = `/event/v1/export-event-ticket-guest/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (eventTicketStatus) {
                localVarQueryParameter['eventTicketStatus'] = eventTicketStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an participants with filter
         * @param {Array<string>} [eventId] 
         * @param {Array<string>} [eventTicketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketGuestControllerFindAll: async (eventId?: Array<string>, eventTicketId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event/v1/event-ticket-guest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (eventId) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (eventTicketId) {
                localVarQueryParameter['eventTicketId'] = eventTicketId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an event guest especific
         * @param {string} id Event Ticket Guest ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketGuestControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventTicketGuestControllerFindOne', 'id', id)
            const localVarPath = `/event/v1/event-ticket-guest/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventTicketGuestApi - functional programming interface
 * @export
 */
export const EventTicketGuestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventTicketGuestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create event ticket links
         * @param {string} eventId Event ID
         * @param {string} eventTicketId Event Ticket ID
         * @param {CreateEventTicketGuestDto} createEventTicketGuestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTicketGuestControllerCreate(eventId: string, eventTicketId: string, createEventTicketGuestDto: CreateEventTicketGuestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventTicketGuestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTicketGuestControllerCreate(eventId, eventTicketId, createEventTicketGuestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Export an tickets
         * @param {string} eventId Event ID
         * @param {Array<string>} [eventTicketStatus] Event ticket status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTicketGuestControllerExportFile(eventId: string, eventTicketStatus?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTicketGuestControllerExportFile(eventId, eventTicketStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an participants with filter
         * @param {Array<string>} [eventId] 
         * @param {Array<string>} [eventTicketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTicketGuestControllerFindAll(eventId?: Array<string>, eventTicketId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTicketGuestControllerFindAll(eventId, eventTicketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an event guest especific
         * @param {string} id Event Ticket Guest ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTicketGuestControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventTicketGuestClubResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTicketGuestControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventTicketGuestApi - factory interface
 * @export
 */
export const EventTicketGuestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventTicketGuestApiFp(configuration)
    return {
        /**
         * 
         * @summary Create event ticket links
         * @param {string} eventId Event ID
         * @param {string} eventTicketId Event Ticket ID
         * @param {CreateEventTicketGuestDto} createEventTicketGuestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketGuestControllerCreate(eventId: string, eventTicketId: string, createEventTicketGuestDto: CreateEventTicketGuestDto, options?: any): AxiosPromise<EventTicketGuestDto> {
            return localVarFp.eventTicketGuestControllerCreate(eventId, eventTicketId, createEventTicketGuestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export an tickets
         * @param {string} eventId Event ID
         * @param {Array<string>} [eventTicketStatus] Event ticket status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketGuestControllerExportFile(eventId: string, eventTicketStatus?: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.eventTicketGuestControllerExportFile(eventId, eventTicketStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an participants with filter
         * @param {Array<string>} [eventId] 
         * @param {Array<string>} [eventTicketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketGuestControllerFindAll(eventId?: Array<string>, eventTicketId?: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.eventTicketGuestControllerFindAll(eventId, eventTicketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an event guest especific
         * @param {string} id Event Ticket Guest ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTicketGuestControllerFindOne(id: string, options?: any): AxiosPromise<EventTicketGuestClubResponse> {
            return localVarFp.eventTicketGuestControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventTicketGuestApi - object-oriented interface
 * @export
 * @class EventTicketGuestApi
 * @extends {BaseAPI}
 */
export class EventTicketGuestApi extends BaseAPI {
    /**
     * 
     * @summary Create event ticket links
     * @param {string} eventId Event ID
     * @param {string} eventTicketId Event Ticket ID
     * @param {CreateEventTicketGuestDto} createEventTicketGuestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTicketGuestApi
     */
    public eventTicketGuestControllerCreate(eventId: string, eventTicketId: string, createEventTicketGuestDto: CreateEventTicketGuestDto, options?: AxiosRequestConfig) {
        return EventTicketGuestApiFp(this.configuration).eventTicketGuestControllerCreate(eventId, eventTicketId, createEventTicketGuestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export an tickets
     * @param {string} eventId Event ID
     * @param {Array<string>} [eventTicketStatus] Event ticket status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTicketGuestApi
     */
    public eventTicketGuestControllerExportFile(eventId: string, eventTicketStatus?: Array<string>, options?: AxiosRequestConfig) {
        return EventTicketGuestApiFp(this.configuration).eventTicketGuestControllerExportFile(eventId, eventTicketStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an participants with filter
     * @param {Array<string>} [eventId] 
     * @param {Array<string>} [eventTicketId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTicketGuestApi
     */
    public eventTicketGuestControllerFindAll(eventId?: Array<string>, eventTicketId?: Array<string>, options?: AxiosRequestConfig) {
        return EventTicketGuestApiFp(this.configuration).eventTicketGuestControllerFindAll(eventId, eventTicketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an event guest especific
     * @param {string} id Event Ticket Guest ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTicketGuestApi
     */
    public eventTicketGuestControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return EventTicketGuestApiFp(this.configuration).eventTicketGuestControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InitialSubscribeApi - axios parameter creator
 * @export
 */
export const InitialSubscribeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Initial Subscribe
         * @param {CreateInitialSubscribeDto} createInitialSubscribeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initialSubscribeControllerCreate: async (createInitialSubscribeDto: CreateInitialSubscribeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInitialSubscribeDto' is not null or undefined
            assertParamExists('initialSubscribeControllerCreate', 'createInitialSubscribeDto', createInitialSubscribeDto)
            const localVarPath = `/subscribe/v1/initial-subscribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInitialSubscribeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Initial Subscribe club
         * @param {string} name 
         * @param {string} email 
         * @param {string} password 
         * @param {string} countryCodePhone 
         * @param {string} areaCodePhone 
         * @param {string} phoneNumber 
         * @param {string} dateOfBirth 
         * @param {string} document 
         * @param {File} photo Arquivo em formato binário
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initialSubscribeControllerCreateClub: async (name: string, email: string, password: string, countryCodePhone: string, areaCodePhone: string, phoneNumber: string, dateOfBirth: string, document: string, photo: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('initialSubscribeControllerCreateClub', 'name', name)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('initialSubscribeControllerCreateClub', 'email', email)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('initialSubscribeControllerCreateClub', 'password', password)
            // verify required parameter 'countryCodePhone' is not null or undefined
            assertParamExists('initialSubscribeControllerCreateClub', 'countryCodePhone', countryCodePhone)
            // verify required parameter 'areaCodePhone' is not null or undefined
            assertParamExists('initialSubscribeControllerCreateClub', 'areaCodePhone', areaCodePhone)
            // verify required parameter 'phoneNumber' is not null or undefined
            assertParamExists('initialSubscribeControllerCreateClub', 'phoneNumber', phoneNumber)
            // verify required parameter 'dateOfBirth' is not null or undefined
            assertParamExists('initialSubscribeControllerCreateClub', 'dateOfBirth', dateOfBirth)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('initialSubscribeControllerCreateClub', 'document', document)
            // verify required parameter 'photo' is not null or undefined
            assertParamExists('initialSubscribeControllerCreateClub', 'photo', photo)
            const localVarPath = `/subscribe/v1/initial-subscribe-club`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
            if (countryCodePhone !== undefined) { 
                localVarFormParams.append('countryCodePhone', countryCodePhone as any);
            }
    
            if (areaCodePhone !== undefined) { 
                localVarFormParams.append('areaCodePhone', areaCodePhone as any);
            }
    
            if (phoneNumber !== undefined) { 
                localVarFormParams.append('phoneNumber', phoneNumber as any);
            }
    
            if (dateOfBirth !== undefined) { 
                localVarFormParams.append('dateOfBirth', dateOfBirth as any);
            }
    
            if (document !== undefined) { 
                localVarFormParams.append('document', document as any);
            }
    
            if (photo !== undefined) { 
                localVarFormParams.append('photo', photo as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InitialSubscribeApi - functional programming interface
 * @export
 */
export const InitialSubscribeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InitialSubscribeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Initial Subscribe
         * @param {CreateInitialSubscribeDto} createInitialSubscribeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initialSubscribeControllerCreate(createInitialSubscribeDto: CreateInitialSubscribeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initialSubscribeControllerCreate(createInitialSubscribeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Initial Subscribe club
         * @param {string} name 
         * @param {string} email 
         * @param {string} password 
         * @param {string} countryCodePhone 
         * @param {string} areaCodePhone 
         * @param {string} phoneNumber 
         * @param {string} dateOfBirth 
         * @param {string} document 
         * @param {File} photo Arquivo em formato binário
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initialSubscribeControllerCreateClub(name: string, email: string, password: string, countryCodePhone: string, areaCodePhone: string, phoneNumber: string, dateOfBirth: string, document: string, photo: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initialSubscribeControllerCreateClub(name, email, password, countryCodePhone, areaCodePhone, phoneNumber, dateOfBirth, document, photo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InitialSubscribeApi - factory interface
 * @export
 */
export const InitialSubscribeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InitialSubscribeApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Initial Subscribe
         * @param {CreateInitialSubscribeDto} createInitialSubscribeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initialSubscribeControllerCreate(createInitialSubscribeDto: CreateInitialSubscribeDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.initialSubscribeControllerCreate(createInitialSubscribeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Initial Subscribe club
         * @param {string} name 
         * @param {string} email 
         * @param {string} password 
         * @param {string} countryCodePhone 
         * @param {string} areaCodePhone 
         * @param {string} phoneNumber 
         * @param {string} dateOfBirth 
         * @param {string} document 
         * @param {File} photo Arquivo em formato binário
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initialSubscribeControllerCreateClub(name: string, email: string, password: string, countryCodePhone: string, areaCodePhone: string, phoneNumber: string, dateOfBirth: string, document: string, photo: File, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.initialSubscribeControllerCreateClub(name, email, password, countryCodePhone, areaCodePhone, phoneNumber, dateOfBirth, document, photo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InitialSubscribeApi - object-oriented interface
 * @export
 * @class InitialSubscribeApi
 * @extends {BaseAPI}
 */
export class InitialSubscribeApi extends BaseAPI {
    /**
     * 
     * @summary Create Initial Subscribe
     * @param {CreateInitialSubscribeDto} createInitialSubscribeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InitialSubscribeApi
     */
    public initialSubscribeControllerCreate(createInitialSubscribeDto: CreateInitialSubscribeDto, options?: AxiosRequestConfig) {
        return InitialSubscribeApiFp(this.configuration).initialSubscribeControllerCreate(createInitialSubscribeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Initial Subscribe club
     * @param {string} name 
     * @param {string} email 
     * @param {string} password 
     * @param {string} countryCodePhone 
     * @param {string} areaCodePhone 
     * @param {string} phoneNumber 
     * @param {string} dateOfBirth 
     * @param {string} document 
     * @param {File} photo Arquivo em formato binário
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InitialSubscribeApi
     */
    public initialSubscribeControllerCreateClub(name: string, email: string, password: string, countryCodePhone: string, areaCodePhone: string, phoneNumber: string, dateOfBirth: string, document: string, photo: File, options?: AxiosRequestConfig) {
        return InitialSubscribeApiFp(this.configuration).initialSubscribeControllerCreateClub(name, email, password, countryCodePhone, areaCodePhone, phoneNumber, dateOfBirth, document, photo, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OTPApi - axios parameter creator
 * @export
 */
export const OTPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change Password
         * @param {ChangePasswordOtpDto} changePasswordOtpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oTPControllerChangePassword: async (changePasswordOtpDto: ChangePasswordOtpDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordOtpDto' is not null or undefined
            assertParamExists('oTPControllerChangePassword', 'changePasswordOtpDto', changePasswordOtpDto)
            const localVarPath = `/otp/v1/otp/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordOtpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate OTP code
         * @param {CreateOtpDto} createOtpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oTPControllerCreate: async (createOtpDto: CreateOtpDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOtpDto' is not null or undefined
            assertParamExists('oTPControllerCreate', 'createOtpDto', createOtpDto)
            const localVarPath = `/otp/v1/otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOtpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validating OTP code
         * @param {ValidateOtpDto} validateOtpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oTPControllerValidateOTP: async (validateOtpDto: ValidateOtpDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateOtpDto' is not null or undefined
            assertParamExists('oTPControllerValidateOTP', 'validateOtpDto', validateOtpDto)
            const localVarPath = `/otp/v1/otp/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateOtpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OTPApi - functional programming interface
 * @export
 */
export const OTPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OTPApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change Password
         * @param {ChangePasswordOtpDto} changePasswordOtpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oTPControllerChangePassword(changePasswordOtpDto: ChangePasswordOtpDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oTPControllerChangePassword(changePasswordOtpDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate OTP code
         * @param {CreateOtpDto} createOtpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oTPControllerCreate(createOtpDto: CreateOtpDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseOTPHashDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oTPControllerCreate(createOtpDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validating OTP code
         * @param {ValidateOtpDto} validateOtpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oTPControllerValidateOTP(validateOtpDto: ValidateOtpDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseOTPHashDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oTPControllerValidateOTP(validateOtpDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OTPApi - factory interface
 * @export
 */
export const OTPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OTPApiFp(configuration)
    return {
        /**
         * 
         * @summary Change Password
         * @param {ChangePasswordOtpDto} changePasswordOtpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oTPControllerChangePassword(changePasswordOtpDto: ChangePasswordOtpDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.oTPControllerChangePassword(changePasswordOtpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate OTP code
         * @param {CreateOtpDto} createOtpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oTPControllerCreate(createOtpDto: CreateOtpDto, options?: any): AxiosPromise<ResponseOTPHashDTO> {
            return localVarFp.oTPControllerCreate(createOtpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validating OTP code
         * @param {ValidateOtpDto} validateOtpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oTPControllerValidateOTP(validateOtpDto: ValidateOtpDto, options?: any): AxiosPromise<ResponseOTPHashDTO> {
            return localVarFp.oTPControllerValidateOTP(validateOtpDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OTPApi - object-oriented interface
 * @export
 * @class OTPApi
 * @extends {BaseAPI}
 */
export class OTPApi extends BaseAPI {
    /**
     * 
     * @summary Change Password
     * @param {ChangePasswordOtpDto} changePasswordOtpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public oTPControllerChangePassword(changePasswordOtpDto: ChangePasswordOtpDto, options?: AxiosRequestConfig) {
        return OTPApiFp(this.configuration).oTPControllerChangePassword(changePasswordOtpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate OTP code
     * @param {CreateOtpDto} createOtpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public oTPControllerCreate(createOtpDto: CreateOtpDto, options?: AxiosRequestConfig) {
        return OTPApiFp(this.configuration).oTPControllerCreate(createOtpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validating OTP code
     * @param {ValidateOtpDto} validateOtpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public oTPControllerValidateOTP(validateOtpDto: ValidateOtpDto, options?: AxiosRequestConfig) {
        return OTPApiFp(this.configuration).oTPControllerValidateOTP(validateOtpDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find an file especific
         * @param {string} key File source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        awsControllerFile: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('awsControllerFile', 'key', key)
            const localVarPath = `/storage/v1/storage/file/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Find an file especific
         * @param {string} key File source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async awsControllerFile(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.awsControllerFile(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageApiFp(configuration)
    return {
        /**
         * 
         * @summary Find an file especific
         * @param {string} key File source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        awsControllerFile(key: string, options?: any): AxiosPromise<File> {
            return localVarFp.awsControllerFile(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI {
    /**
     * 
     * @summary Find an file especific
     * @param {string} key File source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public awsControllerFile(key: string, options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).awsControllerFile(key, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreateUser: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('userControllerCreateUser', 'createUserDto', createUserDto)
            const localVarPath = `/user/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user with filter
         * @param {string} [name] 
         * @param {string} [email] 
         * @param {string} [documentNumber] 
         * @param {string} [city] 
         * @param {number} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll: async (name?: string, email?: string, documentNumber?: string, city?: string, perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (documentNumber !== undefined) {
                localVarQueryParameter['documentNumber'] = documentNumber;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user with email
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindByEmail: async (email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('userControllerFindByEmail', 'email', email)
            const localVarPath = `/user/v1/user/email/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user with ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerFindById', 'id', id)
            const localVarPath = `/user/v1/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerRemove', 'id', id)
            const localVarPath = `/user/v1/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {string} id User ID
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate: async (id: string, updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdate', 'id', id)
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('userControllerUpdate', 'updateUserDto', updateUserDto)
            const localVarPath = `/user/v1/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit photo/avatar a user
         * @param {string} id User ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUploadPhoto: async (id: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUploadPhoto', 'id', id)
            const localVarPath = `/user/v1/user/{id}/photo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerCreateUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreateUser(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user with filter
         * @param {string} [name] 
         * @param {string} [email] 
         * @param {string} [documentNumber] 
         * @param {string} [city] 
         * @param {number} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindAll(name?: string, email?: string, documentNumber?: string, city?: string, perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindAll(name, email, documentNumber, city, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user with email
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindByEmail(email: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindByEmail(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user with ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user
         * @param {string} id User ID
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdate(id: string, updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(id, updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit photo/avatar a user
         * @param {string} id User ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUploadPhoto(id: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUploadPhoto(id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreateUser(createUserDto: CreateUserDto, options?: any): AxiosPromise<ResponseUserDto> {
            return localVarFp.userControllerCreateUser(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user with filter
         * @param {string} [name] 
         * @param {string} [email] 
         * @param {string} [documentNumber] 
         * @param {string} [city] 
         * @param {number} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll(name?: string, email?: string, documentNumber?: string, city?: string, perPage?: number, page?: number, options?: any): AxiosPromise<UsersResponse> {
            return localVarFp.userControllerFindAll(name, email, documentNumber, city, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user with email
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindByEmail(email: string, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.userControllerFindByEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user with ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindById(id: string, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.userControllerFindById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove(id: string, options?: any): AxiosPromise<DeleteUserResponse> {
            return localVarFp.userControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {string} id User ID
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate(id: string, updateUserDto: UpdateUserDto, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.userControllerUpdate(id, updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit photo/avatar a user
         * @param {string} id User ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUploadPhoto(id: string, file?: File, options?: any): AxiosPromise<ResponseUserDto> {
            return localVarFp.userControllerUploadPhoto(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create a user
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerCreateUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerCreateUser(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user with filter
     * @param {string} [name] 
     * @param {string} [email] 
     * @param {string} [documentNumber] 
     * @param {string} [city] 
     * @param {number} [perPage] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindAll(name?: string, email?: string, documentNumber?: string, city?: string, perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindAll(name, email, documentNumber, city, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user with email
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindByEmail(email: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindByEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user with ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindById(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a user
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerRemove(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {string} id User ID
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdate(id: string, updateUserDto: UpdateUserDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdate(id, updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit photo/avatar a user
     * @param {string} id User ID
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUploadPhoto(id: string, file?: File, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUploadPhoto(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



